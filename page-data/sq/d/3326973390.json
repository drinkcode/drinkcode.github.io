{"data":{"allMarkdownRemark":{"nodes":[{"frontmatter":{"tags":["쿠버네티스/도커"],"title":"도커 자원 상태보기"},"internal":{"content":"\n# 도커 자원 상태보기\n\n```bash\n# 실시간 출력\ndocker stats\n\nor\n\n# 한번만 출력\ndocker stats --no-stream\n```\n\n![](./images/test.png)\n"},"html":"<h1 id=\"도커-자원-상태보기\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EC%BB%A4-%EC%9E%90%EC%9B%90-%EC%83%81%ED%83%9C%EB%B3%B4%EA%B8%B0\" aria-label=\"도커 자원 상태보기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도커 자원 상태보기</h1>\n<pre><code class=\"language-bash\"># 실시간 출력\ndocker stats\n\nor\n\n# 한번만 출력\ndocker stats --no-stream\n</code></pre>\n<p><img src=\"./images/test.png\" alt=\"\"></p>"},{"frontmatter":{"tags":["코딩표준"],"title":"코딩표준"},"internal":{"content":"\n# 코딩표준\n\n## 공용\n\n매개변수가 4개 이상이면 묶는다\n함수나 매개변수에 null이 들어가면 변수명에 명시 해준다\n\n예외처리는 내가 아무리 컨트롤 할려고 해도, 나 이외의 예외가 발생한경우를 대비해 쓰는 거다.\nex1) 파일을 읽고 있는데 누가 그 사이에 파일을 지울 때\nex2) 외부에서 웹서버로 요청을 할 때, 보내주는 값이 NULL일 수 있다, 이럴 때 값이 유효한 값인지 검증해야한다\u001e\n그 외에는 남용해서는 안된다\n\n예외처리도 하는데 메모리덤프해서 분석하는게 제품 퀄리티를 높이는데 더 좋을 수 있다\n\n## C\n\n매개변수가 NULL포인터인지 비교\nNULL포인터로 정수상수 0을 사용하지 말고 NULL포인터 전용 매크로를 사용하자\n\n오류코드를 처리해주는 함수는 오류코드 or 오류를 반환해야 한다\n\ninline을 되도록이면 쓰지 않는다, 대신 매크로를 자주 쓰자\n\nstrncpy 사용시 마지막 문자열에 \\0 추가\n\n## C++\n\n전역변수 대신 정적변수(static variable)을 쓸 것\n함수안에 정적변수(static variable) 넣지 않고 클래스 않에 넣을 것\n매크로를 되도록이면 쓰지 않고 inline을 자주 쓰자\n\n생성자를 생성해줄 땐 예외처리가 적절하다, 그러나 여전히 느리다\n\nreserve는 vector를 생성한 직후에 되도록 빨리 써야한다\n\n템플릿은 왠만해선 쓰지말자, 정말 필요한 상황이 아니면(ex 5%이상 성능개선할 수 있음, 쓰지 않으면 복잡해지는 상황)\n\nassert은 항상 좋지만 그 보다 더 좋은건 static_assert다\n\ndefault/delete는 쓰면 좋다\n\n상속해주지 않는것에 final 쓰는 습관\n\noverride 쓰는 습관\n\n포인터에는 NULL 대신 nullptr\n\nenum 대신 enumclass쓰기\n\n함수안에서 static변수 쓰지 않는다\n\nmap에선 자동정렬 때문에 성능이 저하되는 상황이 생길 수 밖에없다.\n따라서 따로 정렬이 필요하지 않다면 unordered_map을 쓰는걸 권장\n\nunique_ptr는 즐겨쓰자\n\n### auto를 쓰면 좋은 상황\n\n1.  ![](@attachment/Clipboard_2021-11-26-17-36-27.png)\n\n![](@attachment/Clipboard_2021-11-26-17-36-43.png) 2.\n![](@attachment/Clipboard_2021-11-26-17-37-45.png)\n![](@attachment/Clipboard_2021-11-26-17-37-58.png)\n\n이 외에는 모두 타입을 명시해주는게 좋다\n\n### auto best practice\n\n![](@attachment/Clipboard_2021-11-26-17-40-51.png)\n![](@attachment/Clipboard_2021-11-26-17-41-00.png)\n\n## Typescript & Javascript\n\n[참고1](https://fe-developers.kakaoent.com/2021/211012-typescript-tip/?utm_source=gaerae.com&utm_campaign=%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%8A%A4%EB%9F%BD%EB%8B%A4&utm_medium=social)\n성능을 위해선 enum 보다는 union type 을 쓰자.\n그렇다고 enum이 꼭 나쁜것은 아니다 enum은 자동완성을 지원해준다\n\nindex signature 보다는 mapped type 을 쓰자.\n\n타입가드는 적극활용 하자\n\n# Typescript & Javascript 안티패턴\n\n## references\n\n[자바스크립트 안티패턴(Antipatterns)의 유형과 사용법](https://mohwaproject.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4Antipatterns%EC%9D%98-%EC%9C%A0%ED%98%95%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95)\n"},"html":"<h1 id=\"코딩표준\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%94%A9%ED%91%9C%EC%A4%80\" aria-label=\"코딩표준 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코딩표준</h1>\n<h2 id=\"공용\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9A%A9\" aria-label=\"공용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공용</h2>\n<p>매개변수가 4개 이상이면 묶는다\n함수나 매개변수에 null이 들어가면 변수명에 명시 해준다</p>\n<p>예외처리는 내가 아무리 컨트롤 할려고 해도, 나 이외의 예외가 발생한경우를 대비해 쓰는 거다.\nex1) 파일을 읽고 있는데 누가 그 사이에 파일을 지울 때\nex2) 외부에서 웹서버로 요청을 할 때, 보내주는 값이 NULL일 수 있다, 이럴 때 값이 유효한 값인지 검증해야한다\u001e\n그 외에는 남용해서는 안된다</p>\n<p>예외처리도 하는데 메모리덤프해서 분석하는게 제품 퀄리티를 높이는데 더 좋을 수 있다</p>\n<h2 id=\"c\" style=\"position:relative;\"><a href=\"#c\" aria-label=\"c permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>C</h2>\n<p>매개변수가 NULL포인터인지 비교\nNULL포인터로 정수상수 0을 사용하지 말고 NULL포인터 전용 매크로를 사용하자</p>\n<p>오류코드를 처리해주는 함수는 오류코드 or 오류를 반환해야 한다</p>\n<p>inline을 되도록이면 쓰지 않는다, 대신 매크로를 자주 쓰자</p>\n<p>strncpy 사용시 마지막 문자열에 \\0 추가</p>\n<h2 id=\"c-1\" style=\"position:relative;\"><a href=\"#c-1\" aria-label=\"c 1 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>C++</h2>\n<p>전역변수 대신 정적변수(static variable)을 쓸 것\n함수안에 정적변수(static variable) 넣지 않고 클래스 않에 넣을 것\n매크로를 되도록이면 쓰지 않고 inline을 자주 쓰자</p>\n<p>생성자를 생성해줄 땐 예외처리가 적절하다, 그러나 여전히 느리다</p>\n<p>reserve는 vector를 생성한 직후에 되도록 빨리 써야한다</p>\n<p>템플릿은 왠만해선 쓰지말자, 정말 필요한 상황이 아니면(ex 5%이상 성능개선할 수 있음, 쓰지 않으면 복잡해지는 상황)</p>\n<p>assert은 항상 좋지만 그 보다 더 좋은건 static_assert다</p>\n<p>default/delete는 쓰면 좋다</p>\n<p>상속해주지 않는것에 final 쓰는 습관</p>\n<p>override 쓰는 습관</p>\n<p>포인터에는 NULL 대신 nullptr</p>\n<p>enum 대신 enumclass쓰기</p>\n<p>함수안에서 static변수 쓰지 않는다</p>\n<p>map에선 자동정렬 때문에 성능이 저하되는 상황이 생길 수 밖에없다.\n따라서 따로 정렬이 필요하지 않다면 unordered_map을 쓰는걸 권장</p>\n<p>unique_ptr는 즐겨쓰자</p>\n<h3 id=\"auto를-쓰면-좋은-상황\" style=\"position:relative;\"><a href=\"#auto%EB%A5%BC-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%83%81%ED%99%A9\" aria-label=\"auto를 쓰면 좋은 상황 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>auto를 쓰면 좋은 상황</h3>\n<ol>\n<li><img src=\"@attachment/Clipboard_2021-11-26-17-36-27.png\" alt=\"\"></li>\n</ol>\n<p><img src=\"@attachment/Clipboard_2021-11-26-17-36-43.png\" alt=\"\"> 2.\n<img src=\"@attachment/Clipboard_2021-11-26-17-37-45.png\" alt=\"\">\n<img src=\"@attachment/Clipboard_2021-11-26-17-37-58.png\" alt=\"\"></p>\n<p>이 외에는 모두 타입을 명시해주는게 좋다</p>\n<h3 id=\"auto-best-practice\" style=\"position:relative;\"><a href=\"#auto-best-practice\" aria-label=\"auto best practice permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>auto best practice</h3>\n<p><img src=\"@attachment/Clipboard_2021-11-26-17-40-51.png\" alt=\"\">\n<img src=\"@attachment/Clipboard_2021-11-26-17-41-00.png\" alt=\"\"></p>\n<h2 id=\"typescript--javascript\" style=\"position:relative;\"><a href=\"#typescript--javascript\" aria-label=\"typescript  javascript permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript &#x26; Javascript</h2>\n<p><a href=\"https://fe-developers.kakaoent.com/2021/211012-typescript-tip/?utm_source=gaerae.com&#x26;utm_campaign=%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%8A%A4%EB%9F%BD%EB%8B%A4&#x26;utm_medium=social\">참고1</a>\n성능을 위해선 enum 보다는 union type 을 쓰자.\n그렇다고 enum이 꼭 나쁜것은 아니다 enum은 자동완성을 지원해준다</p>\n<p>index signature 보다는 mapped type 을 쓰자.</p>\n<p>타입가드는 적극활용 하자</p>\n<h1 id=\"typescript--javascript-안티패턴\" style=\"position:relative;\"><a href=\"#typescript--javascript-%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4\" aria-label=\"typescript  javascript 안티패턴 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript &#x26; Javascript 안티패턴</h1>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>references</h2>\n<p><a href=\"https://mohwaproject.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4Antipatterns%EC%9D%98-%EC%9C%A0%ED%98%95%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95\">자바스크립트 안티패턴(Antipatterns)의 유형과 사용법</a></p>"},{"frontmatter":{"tags":["웹개발 개념정리"],"title":"CPU스레드 & 소프트웨어 스레드"},"internal":{"content":"\n# CPU스레드 & 소프트웨어 스레드\n\n[참고](https://velog.io/@dvmflstm/CPU-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%8A%A4%EB%A0%88%EB%93%9C)\n\n요즘 멀티스레딩 관련 공부를 하다가 문득 궁금한 점이 생겼다.\n\n**\"내 컴퓨터에 박혀 있는 CPU 코어 및 스레드의 수는 정해져 있는데, 소프트웨어 상에서 어떻게 스레드 수를 100개, 200개 씩 설정할 수 있는걸까?\"**\n\n언뜻 보면 굉장히 바보 같은 질문일 수 있지만, 나는 이 질문에 명확히 답하지 못했고 그래서 검색을 통해 스레드에 대해 알아보았다.\n\n### CPU 스레드\n\n물리적 스레드는 CPU 코어와도 관련이 깊다. CPU 코어는 익히 알고 있듯이 intruction을 하나씩 해석하여 연산을 실행하는 유닛을 뜻한다. 스레드란 물리적인 코어 개수와는 별개로 '논리적인' 코어 개수를 뜻하며 통상적으로는 1코어에 1스레드를 돌리는게 일반적이었지만, 코어 사용률을 높여 1코어당 여러 개의 스레드를 동시에 돌리는 하이퍼스레딩 기법이 비교적 최근에 등장하였다.\n말이 좀 헷갈리는데 내 방식대로 정리해 보자면, 스레드는 코어 안에서 Fetch, Decode, Execute, Memory Access, Write 등의 instruction 세부 작업들이 실행되는 series라고 보면 될 것 같다. 보통은 이 작업들이 실행되는 instance가 코어 내에 하나만 존재하는데, 하이퍼 스레딩을 할 시에 여러 개의 instance가 동시에 돌아간다고 생각하면 될 것 같다.\n\n### 소프트웨어 스레드\n\n소프트웨어적인 관점에서 말하는 스레드란 하나의 프로세스가 실행되는 세부 작업들의 단위를 말한다. 운영체제가 스케줄링을 할 때 동시에 실행 가능한 스레드 수(CPU 스레드)는 정해져 있다. 하지만 메모리가 허용하는 소프트웨어적 스레드 수는 얼마든지 많을 수 있다. 이들 중 운영체제에 의해 실행되지 않는 스레드는 잠들어 있을 수도 있으며 운영체제는 이들 중 물리적 스레드가 허용 가능한 만큼의 스레드를 할당하여 동시에 실행시킨다.\n\n---\n\n설명들이 상당히 헷갈리고 복잡하지만, 둘 사이에 기본적인 차이 정도는 이해가 된 것 같고, 소프트웨어 상에서 수많은 스레드를 프로세스에 할당하여 작업을 처리하는 멀티스레딩 방식에 대해 조금 더 깊은 이해가 생긴 것 같다.\n"},"html":"<h1 id=\"cpu스레드--소프트웨어-스레드\" style=\"position:relative;\"><a href=\"#cpu%EC%8A%A4%EB%A0%88%EB%93%9C--%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"cpu스레드  소프트웨어 스레드 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU스레드 &#x26; 소프트웨어 스레드</h1>\n<p><a href=\"https://velog.io/@dvmflstm/CPU-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%8A%A4%EB%A0%88%EB%93%9C\">참고</a></p>\n<p>요즘 멀티스레딩 관련 공부를 하다가 문득 궁금한 점이 생겼다.</p>\n<p><strong>\"내 컴퓨터에 박혀 있는 CPU 코어 및 스레드의 수는 정해져 있는데, 소프트웨어 상에서 어떻게 스레드 수를 100개, 200개 씩 설정할 수 있는걸까?\"</strong></p>\n<p>언뜻 보면 굉장히 바보 같은 질문일 수 있지만, 나는 이 질문에 명확히 답하지 못했고 그래서 검색을 통해 스레드에 대해 알아보았다.</p>\n<h3 id=\"cpu-스레드\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"cpu 스레드 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 스레드</h3>\n<p>물리적 스레드는 CPU 코어와도 관련이 깊다. CPU 코어는 익히 알고 있듯이 intruction을 하나씩 해석하여 연산을 실행하는 유닛을 뜻한다. 스레드란 물리적인 코어 개수와는 별개로 '논리적인' 코어 개수를 뜻하며 통상적으로는 1코어에 1스레드를 돌리는게 일반적이었지만, 코어 사용률을 높여 1코어당 여러 개의 스레드를 동시에 돌리는 하이퍼스레딩 기법이 비교적 최근에 등장하였다.\n말이 좀 헷갈리는데 내 방식대로 정리해 보자면, 스레드는 코어 안에서 Fetch, Decode, Execute, Memory Access, Write 등의 instruction 세부 작업들이 실행되는 series라고 보면 될 것 같다. 보통은 이 작업들이 실행되는 instance가 코어 내에 하나만 존재하는데, 하이퍼 스레딩을 할 시에 여러 개의 instance가 동시에 돌아간다고 생각하면 될 것 같다.</p>\n<h3 id=\"소프트웨어-스레드\" style=\"position:relative;\"><a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"소프트웨어 스레드 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소프트웨어 스레드</h3>\n<p>소프트웨어적인 관점에서 말하는 스레드란 하나의 프로세스가 실행되는 세부 작업들의 단위를 말한다. 운영체제가 스케줄링을 할 때 동시에 실행 가능한 스레드 수(CPU 스레드)는 정해져 있다. 하지만 메모리가 허용하는 소프트웨어적 스레드 수는 얼마든지 많을 수 있다. 이들 중 운영체제에 의해 실행되지 않는 스레드는 잠들어 있을 수도 있으며 운영체제는 이들 중 물리적 스레드가 허용 가능한 만큼의 스레드를 할당하여 동시에 실행시킨다.</p>\n<hr>\n<p>설명들이 상당히 헷갈리고 복잡하지만, 둘 사이에 기본적인 차이 정도는 이해가 된 것 같고, 소프트웨어 상에서 수많은 스레드를 프로세스에 할당하여 작업을 처리하는 멀티스레딩 방식에 대해 조금 더 깊은 이해가 생긴 것 같다.</p>"},{"frontmatter":{"tags":["블로그 포스팅"],"title":"프로세스 스레드 개념"},"internal":{"content":"\n# 프로세스 스레드 개념\n\n# 참고자료\n\n[12bme 블로그](https://12bme.tistory.com/65)\n\n에전에 까먹을 때마다 한번씩 다시 공부했는데 또 까먹을까봐 여기에 박제해 놓는다.\n\n# 프로세스, 스레드 개념\n\n**프로세스란 무엇인가?**\n\n**\\- 프로세스 :** 자기 자신만의 주소 공간을 갖는 독립적인(Self\\-Contained) 실행 프로그램\n\n**\\- 멀티 프로세스 :** 두 개 이상의 프로세스가 실행되는 것. 프로그램이 여러개 띄워져 있는 형식.\n\n**\\- 멀티 태스킹 :** 두 개 이상의 프로세스를 실행하여 일을 처리하는 것\n\n> **프로그램 :** 스태틱하게 머신에 인스톨되어있는 인스트럭션(코드, 커맨드, 실행해야할 명령)등의 집합\n>\n> **프로세스 :** 프로그램이 실행중(프로그램 안의 인스트럭션들이 실행되고 있는 중)인 것.\n\n**스레드란 무엇인가?**\n\n**\\- 스레드(경량 프로세스) :** 프로세스 내의 독립적인 순차흐름 또는 제어\n\n**\\- 멀티 스레드 :** 하나의 프로세스에서 여러 개의 스레드가 병행적으로 처리\n\n![](https://t1.daumcdn.net/cfile/tistory/230B7D3359019EBE18)\n\n프로세스 내에 스레드란 개념이 포함되어 있으므로 스레드와 프로세스는 서로 연관이 되어 있습니다. 프로세스는 실행중인 프로그램 객체 자체를 말하고, 하나의 실행흐름 자체를 스레드라고 말합니다. 하나의 프로세스안에 스레드가 여러개 있는 것을 멀티 스레드라고 말합니다.\n\n네트워크 프로그래밍을 할때에는 멀티 쓰레딩이 필요합니다. 게임프로그래밍에서 특히 멀티 스레드를 많이 사용하게 됩니다. 예를 들면, 사용자가 게임을 하려면 크게 1.사용자의 input, 2.네트워크로부터 전송되는 input  두개의 input 이 있게 됩니다. 1,2 는 동시에 병렬적으로 일어나야 합니다.\n\n한 프로세스에 스레드가 2 개있다는 말은 해단 프로세스 내 실행흐름이 2 개 존재한다는 의미와 동일합니다. 한 프로그램 안에서 여러가지 태스크를 동시 수행하고 싶을때, 쓰레드를 사용하게 됩니다. **네트워크 프로그래밍에서는 반드시 필요합니다.** 예를 들면, 가장 간단한 네트워크 프로그래밍인 채팅 프로그램에서는 채팅메시지에서 채팅을 쓰는 부분(키보드 input), 상대방의 채팅메시지를 전달받는 부분(network input) 결과적으로 single thread 에서는 부자연스럽게 돌아가게 될 것입니다.\n\n하나의 실행중인 프로세스 안에 여러개의 태스킹을 동시에 실행하고 싶을때 스레드를 이용하게 됩니다.\n\n![](https://t1.daumcdn.net/cfile/tistory/237976395901A1A004)\n\n![](https://t1.daumcdn.net/cfile/tistory/242C8E385901A1AC10)\n\n**스레드의 활용**\n\n> **1) 게임 프로그래밍**\n>\n> \\- 게임에 등장하는 캐릭터를 움직이게 하는 스레드\n>\n> \\- 여러 캐릭터들이 동시에 움직인다 (대부분의 게임에서 각 캐릭터는 각각의 스레드를 가짐)\n>\n> **2) N/W 프로그래밍**\n>\n> \\- 프로그램의 흐름을 담당하는 스레드\n>\n> \\- 네트워크로부터 데이터를 기다리는 스레드\n\n**멀티 프로그래밍**\n\n\\- 여러 개의 프로그램들이 단일 CPU 상에서 동시에 실행되는 것\n\n\\- 컴퓨터에는 한 개의 CPU 내에 존재하기 때문에 진정한 의미로는 여러개의 프로그램이 동시에 실행된다고 볼 수는 없습니다.\n\n\\- 한 프로그램이 일부 실행되고 나서 또 다른 프로그램이 일부 실행되는 방식입니다.\n\n**\\- 모든 프로그램이 동시에 수행되는것처럼 보이게 됩니다.**\n\n궁극적으로 프로세스간에도 스위치가 일어나고 있고, 스레드 안에서도 스위치가 일어나고 있는 모습(CPU 를 갖고있는 동안)이 됩니다. 그리고 프로그래밍시에는 스레드는 각각 별도의 함수로 구성되어 있습니다.\n\n**스레드의 생명주기**\n\n스레드의 생명주기는 프로세스의 생명주기와 유사합니다. java 에서 프로세스 생명주기를 나타내는 그림입니다.\n\n![](https://t1.daumcdn.net/cfile/tistory/2111A6425901AE9D35)\n\n프로그램이 실행되면 메인부터 시작하여 하나하나씩 개발자가 짠 함수들이 순차적으로 실행됩니다. 이때 a(), b()라는 함수가 있는데, 동시에 실행하고 싶을때 쓰레드를 이용하게 됩니다. 각 함수별로 해당 함수를 실행하는 스레드를   생성합니다.\n\n자바에서 실행되는 모든 엔티티는 객체입니다. 쓰레드 역시 마찬가지로 객체입니다. 쓰레드를 실행하는 메소드(start()) 실행하면 쓰레드가 동작하면서  CPU 가 점유된 상태가 됩니다.\n\n스레드 이후 커리큘럼은 파일 IO 에 대한 설명이 이루어지는데, 파일 IO 역시 네트워크 프로그래밍과 연결되어 있습니다. 왜냐하면 네트워크 프로그래밍은 결국 네트워크 IO 를 사용하겠다는 의미이기 때문입니다.\n"},"html":"<h1 id=\"프로세스-스레드-개념\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%9C%EB%85%90\" aria-label=\"프로세스 스레드 개념 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 스레드 개념</h1>\n<h1 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h1>\n<p><a href=\"https://12bme.tistory.com/65\">12bme 블로그</a></p>\n<p>에전에 까먹을 때마다 한번씩 다시 공부했는데 또 까먹을까봐 여기에 박제해 놓는다.</p>\n<h1 id=\"프로세스-스레드-개념-1\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%9C%EB%85%90-1\" aria-label=\"프로세스 스레드 개념 1 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스, 스레드 개념</h1>\n<p><strong>프로세스란 무엇인가?</strong></p>\n<p><strong>- 프로세스 :</strong> 자기 자신만의 주소 공간을 갖는 독립적인(Self-Contained) 실행 프로그램</p>\n<p><strong>- 멀티 프로세스 :</strong> 두 개 이상의 프로세스가 실행되는 것. 프로그램이 여러개 띄워져 있는 형식.</p>\n<p><strong>- 멀티 태스킹 :</strong> 두 개 이상의 프로세스를 실행하여 일을 처리하는 것</p>\n<blockquote>\n<p><strong>프로그램 :</strong> 스태틱하게 머신에 인스톨되어있는 인스트럭션(코드, 커맨드, 실행해야할 명령)등의 집합</p>\n<p><strong>프로세스 :</strong> 프로그램이 실행중(프로그램 안의 인스트럭션들이 실행되고 있는 중)인 것.</p>\n</blockquote>\n<p><strong>스레드란 무엇인가?</strong></p>\n<p><strong>- 스레드(경량 프로세스) :</strong> 프로세스 내의 독립적인 순차흐름 또는 제어</p>\n<p><strong>- 멀티 스레드 :</strong> 하나의 프로세스에서 여러 개의 스레드가 병행적으로 처리</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/230B7D3359019EBE18\" alt=\"\"></p>\n<p>프로세스 내에 스레드란 개념이 포함되어 있으므로 스레드와 프로세스는 서로 연관이 되어 있습니다. 프로세스는 실행중인 프로그램 객체 자체를 말하고, 하나의 실행흐름 자체를 스레드라고 말합니다. 하나의 프로세스안에 스레드가 여러개 있는 것을 멀티 스레드라고 말합니다.</p>\n<p>네트워크 프로그래밍을 할때에는 멀티 쓰레딩이 필요합니다. 게임프로그래밍에서 특히 멀티 스레드를 많이 사용하게 됩니다. 예를 들면, 사용자가 게임을 하려면 크게 1.사용자의 input, 2.네트워크로부터 전송되는 input  두개의 input 이 있게 됩니다. 1,2 는 동시에 병렬적으로 일어나야 합니다.</p>\n<p>한 프로세스에 스레드가 2 개있다는 말은 해단 프로세스 내 실행흐름이 2 개 존재한다는 의미와 동일합니다. 한 프로그램 안에서 여러가지 태스크를 동시 수행하고 싶을때, 쓰레드를 사용하게 됩니다. <strong>네트워크 프로그래밍에서는 반드시 필요합니다.</strong> 예를 들면, 가장 간단한 네트워크 프로그래밍인 채팅 프로그램에서는 채팅메시지에서 채팅을 쓰는 부분(키보드 input), 상대방의 채팅메시지를 전달받는 부분(network input) 결과적으로 single thread 에서는 부자연스럽게 돌아가게 될 것입니다.</p>\n<p>하나의 실행중인 프로세스 안에 여러개의 태스킹을 동시에 실행하고 싶을때 스레드를 이용하게 됩니다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/237976395901A1A004\" alt=\"\"></p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/242C8E385901A1AC10\" alt=\"\"></p>\n<p><strong>스레드의 활용</strong></p>\n<blockquote>\n<p><strong>1) 게임 프로그래밍</strong></p>\n<p>- 게임에 등장하는 캐릭터를 움직이게 하는 스레드</p>\n<p>- 여러 캐릭터들이 동시에 움직인다 (대부분의 게임에서 각 캐릭터는 각각의 스레드를 가짐)</p>\n<p><strong>2) N/W 프로그래밍</strong></p>\n<p>- 프로그램의 흐름을 담당하는 스레드</p>\n<p>- 네트워크로부터 데이터를 기다리는 스레드</p>\n</blockquote>\n<p><strong>멀티 프로그래밍</strong></p>\n<p>- 여러 개의 프로그램들이 단일 CPU 상에서 동시에 실행되는 것</p>\n<p>- 컴퓨터에는 한 개의 CPU 내에 존재하기 때문에 진정한 의미로는 여러개의 프로그램이 동시에 실행된다고 볼 수는 없습니다.</p>\n<p>- 한 프로그램이 일부 실행되고 나서 또 다른 프로그램이 일부 실행되는 방식입니다.</p>\n<p><strong>- 모든 프로그램이 동시에 수행되는것처럼 보이게 됩니다.</strong></p>\n<p>궁극적으로 프로세스간에도 스위치가 일어나고 있고, 스레드 안에서도 스위치가 일어나고 있는 모습(CPU 를 갖고있는 동안)이 됩니다. 그리고 프로그래밍시에는 스레드는 각각 별도의 함수로 구성되어 있습니다.</p>\n<p><strong>스레드의 생명주기</strong></p>\n<p>스레드의 생명주기는 프로세스의 생명주기와 유사합니다. java 에서 프로세스 생명주기를 나타내는 그림입니다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/2111A6425901AE9D35\" alt=\"\"></p>\n<p>프로그램이 실행되면 메인부터 시작하여 하나하나씩 개발자가 짠 함수들이 순차적으로 실행됩니다. 이때 a(), b()라는 함수가 있는데, 동시에 실행하고 싶을때 쓰레드를 이용하게 됩니다. 각 함수별로 해당 함수를 실행하는 스레드를   생성합니다.</p>\n<p>자바에서 실행되는 모든 엔티티는 객체입니다. 쓰레드 역시 마찬가지로 객체입니다. 쓰레드를 실행하는 메소드(start()) 실행하면 쓰레드가 동작하면서  CPU 가 점유된 상태가 됩니다.</p>\n<p>스레드 이후 커리큘럼은 파일 IO 에 대한 설명이 이루어지는데, 파일 IO 역시 네트워크 프로그래밍과 연결되어 있습니다. 왜냐하면 네트워크 프로그래밍은 결국 네트워크 IO 를 사용하겠다는 의미이기 때문입니다.</p>"},{"frontmatter":{"tags":["고성능 아키텍쳐"],"title":"대규모 웹 서비스란"},"internal":{"content":"\n# 대규모 웹 서비스란\n\n**대규모 웹 서비스**\n\n---\n\n대규모 웹 서비스란, 거대한 데이터를 처리해야만 하는 웹 서비스를 말합니다.\n\n대규모 서비스의 규모감, 대규모 데이터를 다루는 데 있어 어려운 점, 개발 모습을 인지하는 것은 대규모 서비스 개발자에게 필요되는 지식입니다. 사용자가 이용하고 있는 대규모 서비스에 변경을 가할 때 규모를 고려하지 않고 어중간하게 구현해서 적용하다 보면, 시스템 정지를 초래할 수 있습니다.\n\n대규모 웹서비스에 대해 알아보기전 크게 다음에 대한 개념을 잡고 가는 것이 좋습니다.\n\n> **대규모 웹 서비스 개발이란?**\n>\n> \\- 대규모 데이터를 다룰 때의 과제, 다루기 위한 기본적인 사고방식과 요령.\n>\n> ex) OS의 캐시(cache) 기능이나 대규모 데이터를 전제로 한 DB 운용 방법\n>\n> \\- 알고리즘과 데이터 구조 선택의 중요성. 대규모 데이터를 예로 생각.\n>\n> \\- RDBMS(Relational DataBase Management System)로 모두 다룰 수 없는 규모의 데이터 처리 방법.\n>\n> ex) 전문 검색 엔진\n>\n> \\- 대규모 서비스가 될 것을 전제로 한 서버/인프라 시스템.\n\n대규모 서비스는 미들웨어 설정방법이나 프로그래밍 언어의 구문 등 세세한 부분까지 컨트롤해야하는 부분이 굉장히 많습니다. 대규모 서비스, 대규모 데이터를 다룰 경우를 대비한 기본적인 사고방식이나 개념, 개요에 대한 설명에 대해 학습하는 것을 목표로합니다.\n\n> **대규모 서비스 데이터 센터 모습의 예**\n>\n> \\- 등록 사용자는 100만 명 이상, 1,500만 UU(Unique User, 고유 사용자)/월\n>\n> \\- 수십 억 액세스/월(이미지 등으로의 액세스는 제외)\n>\n> \\- 피크(peak) 시 회선 트래픽 양은 430Mbps\n>\n> \\- 하드웨어(서버)는 500대 이상\n\n100만 명 이상의 사용자들이 블로그를 쓰거나 북마크를 등록하고 있고, 월간 1,500만 명이 방문하고 있습니다. 이 방문자 수에 의해 월간 수십억 액세스가 발생합니다. 이 정도의 액세스가 되면 일일 액세스 로그는 기본적으로 기가바이트(gigabyte) 크기가 되며, DB 서버가 저장하는 데이터 규모도 대략 기가바이트 수준, 많을 때는 테라바이트(terabyte ) 정도가 됩니다.\n\n물리적으로 한대의 서버 내에 복수의 호스트가 가동되고 있으므로, 500대 규모의 물리적 서버가 존재한다면 결과적으로 1,000대 이상의 호스트를 가지게 됩니다. 이정도 규모에서는 호스트 정보를 관리하기 위한 툴 등이 필요해집니다.\n\n서비스의 규모는 서버대수 등으로 개략적으로 파악되는 경우가 많은데, 이런 관점에서 볼 때 백 대에서 수천 대 정도가 대규모 서비스라고 할 수 있습니다.\n\nGoogle 및 해외에서 인기 있는 SNS로 최근 구글의 트래픽을 앞지른 전례가 있는 페이스북과 같은 세계 Top 클래스 사이트는 서버 대수가 수백만 대 규모이고, 처리하는 데이터는 테라바이트~페타바이트(petabyte)급의 초대규모 서비스입니다.\n\n**소규모 서비스와 대규모 서비스의 차이**\n\n---\n\n서버 몇 대 정도의 소규모 서비스에는 없는, 대규모 서비스에만 있는 문제나 어려움이 있으며 그 내용은 다음과 같습니다.\n\n**1. 확장성 확보, 부하분산 필요**\n\n대량의 액세스가 있는 서비스에서는 **서버 1대로 처리할 수 없는 부하를 어떻게 처리할 것인지가 가장 큰 문제입니다. '스케일아웃(scale\\-out)'이 이 문제에 대한 전략의 기초가 됩니다.** 스케일아웃은 서버를 횡적으로 전개, 서버의 역할을 분담하거나 대수를 늘림으로써 시스템의 전체적인 처리능력을 높여서 부하를 분산하는 방법입니다. 반면 '스케일업(scale\\-up)'은 하드웨어의 성능을 높여 처리능력을 끌어올리는 방법입니다.\n\n저가의 하드웨어를 횡으로 나열해서 확장성을 확보하는 것이 스케일아웃 전략입니다. 스케일아웃 전략을 채용한 경우는 비용이 절감되는 반면 다양한 문제가 발생합니다. 서버가 1대였을 때에는 전혀 생각지 않아도 될 문제입니다.\n\n**1) 사용자로부터 요청을 어떻게 분배할 것인가?**\n\n해답으로는 로드밸런서를 사용한다는 것인데, 서버 1대일 때에는 애초에 로드밸런서를 도입하는 것 자체를 생각할 필요도 없습니다.\n\n**2) 데이터 동기화는 어떻게 할 것인가?**\n\nDB를 분산시켰을 때 한쪽에 저장된 갱신 내용을 다른 한쪽 DB가 알지 못한다면 애플리케이션에 비정상 사태가 발생합니다.\n\n**3) 네트워크 통신의 지연시간(latency)를 어떻게 생각해 볼 수 있을까?**\n\n작은 데이터라도 이더넷(Ethernet)을 경유해서 통신한 경우는 밀리초(ms) 단위의 지연시간이 있습니다. 밀리초라고 하면 사람이 체감하기로는 그다지 긴 시간이 아니더라도 마이크로초나 나노초에 작동하는 컴퓨터에 있어서는 매우 긴 시간입니다. 통신의 오버헤드를 최소한으로 줄여가면서 애플리케이션을 구성해갈 필요가 있습니다.\n\n**2. 다중성 확보**\n\n스케일아웃을 해서 서버 대수가 늘어나면 서버의 고장률도 필연적으로 올라가게 됩니다. 그러므로 어딘가 잘못되면 서비스가 전부 정지해버리는 설계는 24시간 365일 계속 가동되어야 하는 웹서비스에서는 도저히 용납할 수 없습니다. 서버가 고장나더라도 혹은 급격하게 부하가 올라갈 경우에도 견딜 수 있는 시스템을 구성할 필요가 있습니다. 서비스가 대규모화되면 될수록 시스템 정지의 사회적 충격도 늘어나므로 더욱더 다중성 확보가 중요해집니다.\n\n2001년 9월, 미국 동시다발적인 테러 발생 상황을 알고자 사람들이 일제히 야후에 액세스해서 야후 Top 페이지가 다운돼버리는 사태가 일어났다고 합니다. 야후는 이때 CDN 서비스인 Akamai에 컨텐츠를 캐싱해서 트래픽을 우회시킴으로써 장애를 복구했다고 합니다.\n\n웹 서비스는 언제 어떠한 경우라도 고장에 대해 견고해야 합니다. 이는 상당히 어려운 과제인데, 시스템이 고장나면 그걸로 끝이어도 괜찮은 시스템 구축과 고장 나더라도 다른 시스템이 자동적으로 처리를 인계받는 시스템 구축 간에는 기술적으로나 비용면에서 상당히 큰 차이가 있습니다.\n\n**3. 효율적 운용 필요**\n\n서버가 1대라면 때때로 상태를 확인하는 정도로 서버가 정상적으로 동작하고 있는지를 간단하게 파악할 수 있을 것입니다. 반면 서버 대수가 100대를 넘어서면 어떤 서버가 무슨 역할을 하고 있는지 등에 대한 관리가 어려워집니다. 부하는 괜찮은지, 고장 난 부분은 없는지, 디스크 용량은 아직 충분한지, 보안설정에 미비한 점은 없는지 등등... 이를 모든 서버에 대해 여기저기 잘 살펴야 합니다.\n\n이에 대한 해결 방안으로 **소프트웨어를 사용하고 정보관리를 위한 툴을 사용하는 등 자동화를 하게 됩니다.** 그러나 이 감시 소프트웨어를 설치하거나 정보를 보는 것은 결국 인간입니다. 대규모 시스템을 건강한 상태로 얼마나 계속 유지해갈 수 있을 것인가? 이를 위한 효율적 운용을 수행해야 합니다.\n\n**4. 개발자 수, 개발방법의 변화**\n\n대규모 서비스가 되면 당연히 혼자서는 개발이나 운용이 어려워지므로 여러 기술자가 역할을 분담하게 됩니다. 애플리케이션을 각각의 기술자가 제멋대로 구현한 시스템의 전말을 생각하고 싶지 않습니다.\n\n**프로그래밍 언어를 통일하고, 라이브러리나 프레임워크를 통일하고, 코딩 규약을 정해서 표준화하고, 소스코드 관리를 버전관리 시스템으로 제대로 하는 등 이러한 사항들이 올바르게 실행되기 시작해야 여러 사람이 작업할 때 좋은 효율이 나타납니다.** 여러 사람이 제각기 작업해서는 사람이 늘어나도 생산성은 오르지 않습니다.\n\n**대규모 데이터량에 대한 대처**\n\n---\n\n컴퓨터는 디스크에서 데이터를 로드해서 메모리에 저장, 메모리에 저장된 데이터를 CPU가 fetch해서 특정 처리를 수행합니다. 또한 메모리에서 패치된 명령은 보다 빠른 캐시 메모리에 캐싱됩니다. 이처럼 데이터는 **디스크→메모리→캐시 메모리→CPU**와 같이 몇 단계를 경유해서 처리 되어 갑니다.\n\n각 단계 간에는 속도차는 매우 크게 나는 것이 현대 컴퓨터의 특징입니다. 하드디스크에서 데이터를 읽어들이는 데에는 그 특성상 헤드 이동이나 디스크 원반의 회전이라는 물리적 동작이 수반됩니다. 따라서 전기적으로 읽어들이기만 하면 되는 메모리나 캐시 메모리와 비교하면 10^6~10^9배나 되는 속도차가 나게 됩니다.\n\n이 속도차를 흡수하기 위해 OS는 이런저런 방법을 사용하게 됩니다. 예를 들면 디스크로부터 읽어들인 데이터를 메모리에 캐싱해둠으로써 전반적으로 디바이스간 속도차가 체감속도에 영향을 주지 않도록 하고 있습니다. DB를 비롯한 미들웨어도 기본적으로 이러한 속도차를 의식한 데이터 구조, 구현을 채용하고 있습니다.\n\n하지만 OS나 미들웨어 등의 소프트웨어에서 이런 구조를 통해 분발한다고해도 당연히 한계는 있습니다. 데이터량이 많아지면 처음부터 캐시 미스(cache miss)가 많이 발생하게 되고, 그 결과로 저속의 디스크로의 I/O가 많이 발생하게 됩니다. 디스크 I/O 대기에 들어선 프로그램은 다른 리 소스가 비어 있더라도 읽기가 완료되기까지는 다음 처리를 수행할 수가 없습니다. 이것이 시스템 전체의 속도저하를 초래합니다.\n\n대규모 웹 애플리케이션을 운용할 때 대부분의 어려움은 이러한 대규모 데이터 처리에 집중됩니다.\n\n데이터가 적을 때에는 특별히 고민하지 않아도 모두 메모리에서 처리할 수 있으며, 복잡한 알고리즘을 사용하기보다 간단한 알고리즘을 사용하는 편이 오버헤드가 적기 때문에 더 빠른 경우도 종종 있으므로 I/O 부하는 일단 문제가 되지 않습니다. **그러나 서비스가 어느 정도 이상의 규모가 되면 데이터는 증가합니다. 이 데이터량이 분수령을 넘어서면 문제가 복잡해집니다. 그리고 응급처리로는 쉽사리 풀리지 않습니다. 이 점이 대규모 서비스의 어려운 점입니다.**\n\n어떻게 하면 데이터를 적게 가져갈 수 있을까. 여러 서버로 분산시킬 수 있을까, 필요한 데이터를 최소한의 횟수로 읽어들일 수 있을까 등등.. 이것이 본질적인 과제가 됩니다.\n\n**시스템 규모확장에서의 시행착오**\n\n---\n\n하테나의 규모확장에 대한 대처는 시행착오의 연속이였다고 합니다. 먼저 라우터는 Linux 박스로 저가에 구축, HTTP 요청 분산은 아파치의 mod_rewrite로 대용, DB분산은 MySQL의 레플리케이션 기능을 사용하기 시작하다 블로그 붐이 일어나며 트래픽 증가에 비해 시스템 확장이 따라가지 못하게 되었습니다. 당시는 분산뿐 아니라 다중화, 효율적 운용면에서도 미비한 점이 많았는데, 다중화된 시스템이 자동으로 가동되는 것이 아니라 근처에 살고 있는 엔지니어가 알아차리고 Hang\\-Up된 서버를 재기동하는 등의 응급처치로 견뎌냈습니다.\n\n이후 트래픽이 지속적으로 증가하면서, 임대해서 쓰던 작은 서버룸이 서버 증설에 따라 전력이 부족하게 되면서 더이상 서버를 추가할 수 없는, 추가하게 되면 전류 차단기가 내려가버리게 되는 상황에 처하게 되었습니다.\n\n**데이터 센터로의 이전, 시스템 쇄신**\n\n---\n\n더이상 손쓸 방법이 없는 상황이 되어서야 조직체제를 재점검하고 시스템 운용 전담팀을 구성하여 대응에 임했다고 합니다. 이때부터 1년에 걸쳐 작은 서버 룸에서 인터넷 데이터 센터로 서버를 이전하는 작업을 시작했습니다. 이전 작업을 하면서 네트워크 설계를 근본적으로 재수정하고 낡은 서버는 모두 교체하는 방침을 채택했습니다.\n\n우선은 사전에 기존 시스템의 부하상황을 정리했습니다. 이 정보를 활용해서 각 서비스의 구성 중에 병목지점을 측정, 판정하고 I/O 부하가 높은 서버는 메모리를 중요시하고 CPU 부하가 높은 서버는 CPU를 중요시하는 형태로 서버 용도에 맞게 최적의 구성을 갖는 하드웨어를 준비해갔습니다.\n\n다중화의 경우 로드밸런서 +가동감시 기능을 하는 오픈소스 소프트웨어인 LVS + keepalived를 도입했으며, 이에 따라 Linux 박스로 저가에 구축한 로드밸런서를 각 부문에 도입함으로써 차츰 개선해 나갔습니다. 서버 교체에 있어서는 서서히 OS 가상화도 진행해서 서버 가동률을 높임과 동시에 유지보수성을 높여 갔습니다.\n\n서버의 정보관리를 위해 독자적인 웹 기반 서버 정보관리 시스템도 개발하였으며, 이에 따라 서버의 용도나 부하상태와 같은 각종 정보에 액세스하기 쉬워져서 시스템 전체를 파악하기 용이해졌습니다.\n\n서버/인프라 측면의 시스템 구성뿐만 아니라 애츨리케이션의 각종 로직이나 DB 스키마 등도 재검토해서 비효율적인 부문을 서서히 배제해갔습니다. 필요에 따라 검색 엔진 등의 서브시스템을 독자 개발하는 경우도 있었습니다.\n\n그러나 시스템이 안정되었다고해도 거기서 멈춰버리는 것이 아니라 결국 그 이후의 성장을 위해서는 다시 예전과 동일한 작업을 반복해야만 합니다. 그러지 않기 위해 현재도 개발 담당, 인프라 담당이 하나가 되어 밤낮없이 시스템 품질개선을 수행을 진행 중입니다.\n\n**대규모 서비스에서 기술팀**\n\n---\n\n대규모 서비스에서 서비스 개발부는 각종 서비스 구현을 담당하며, 매일 애플리케이션 측면의 개선을 담당합니다. 서버/인프라 시스템은 1,000대 규모의 호스트를 보유하는 큰시스템이므로 전담팀이 그 운용을 담당하게 되는데, 고장, 과부하, 설정미비, 노후화로 인한 교체 등등. 이런 문제들을 전담해서 맡으면서 가상화나 클라우드 등 보다 세련된 새로운 모습으로 시스템을 확장해 가는 것도 인프라부의 일입니다. 서비스 개발부는 서버/인프라 시스템이 지탱하는 기반 위에 서비스를 개발합니다. 부하 상황은 서버/인프라팀이 감시하고 있고, 인프라 부분의 개선으로 대처할 수 있는 문제는 그들이 즉시 대응하게 되지만, 애플리케이션에 원인이 있는 경우 등 구현이 관련된 경우에는 서비스 개발부와 협력해서 대응합니다.\n\n서비스발부에서도 담당하고 있는 서비스의 성능을 트래킹하고 있으며, 주요한 페이지가 어느 정도의 응답시간에 응답하고 있느지를 정량화해서 매일 그것을 지표로 한계값(threshold)를 밑돌지 않도록 목표를 설정한 개선을 진행합니다.\n\n> **엔지니어가 개발에 사용하고 있는 툴의 종류**\n>\n> \\- 프로그래밍 언어\n>\n> \\- 주요 미들웨어\n>\n> \\- 웹 애플리케이션 프레임워크\n>\n> \\- 주위 머신의 OS 및 에디터\n>\n> \\- 버전관리, BTS(Bug Tracking System, 버그추적 시스템)\n"},"html":"<h1 id=\"대규모-웹-서비스란\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%9E%80\" aria-label=\"대규모 웹 서비스란 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대규모 웹 서비스란</h1>\n<p><strong>대규모 웹 서비스</strong></p>\n<hr>\n<p>대규모 웹 서비스란, 거대한 데이터를 처리해야만 하는 웹 서비스를 말합니다.</p>\n<p>대규모 서비스의 규모감, 대규모 데이터를 다루는 데 있어 어려운 점, 개발 모습을 인지하는 것은 대규모 서비스 개발자에게 필요되는 지식입니다. 사용자가 이용하고 있는 대규모 서비스에 변경을 가할 때 규모를 고려하지 않고 어중간하게 구현해서 적용하다 보면, 시스템 정지를 초래할 수 있습니다.</p>\n<p>대규모 웹서비스에 대해 알아보기전 크게 다음에 대한 개념을 잡고 가는 것이 좋습니다.</p>\n<blockquote>\n<p><strong>대규모 웹 서비스 개발이란?</strong></p>\n<p>- 대규모 데이터를 다룰 때의 과제, 다루기 위한 기본적인 사고방식과 요령.</p>\n<p>ex) OS의 캐시(cache) 기능이나 대규모 데이터를 전제로 한 DB 운용 방법</p>\n<p>- 알고리즘과 데이터 구조 선택의 중요성. 대규모 데이터를 예로 생각.</p>\n<p>- RDBMS(Relational DataBase Management System)로 모두 다룰 수 없는 규모의 데이터 처리 방법.</p>\n<p>ex) 전문 검색 엔진</p>\n<p>- 대규모 서비스가 될 것을 전제로 한 서버/인프라 시스템.</p>\n</blockquote>\n<p>대규모 서비스는 미들웨어 설정방법이나 프로그래밍 언어의 구문 등 세세한 부분까지 컨트롤해야하는 부분이 굉장히 많습니다. 대규모 서비스, 대규모 데이터를 다룰 경우를 대비한 기본적인 사고방식이나 개념, 개요에 대한 설명에 대해 학습하는 것을 목표로합니다.</p>\n<blockquote>\n<p><strong>대규모 서비스 데이터 센터 모습의 예</strong></p>\n<p>- 등록 사용자는 100만 명 이상, 1,500만 UU(Unique User, 고유 사용자)/월</p>\n<p>- 수십 억 액세스/월(이미지 등으로의 액세스는 제외)</p>\n<p>- 피크(peak) 시 회선 트래픽 양은 430Mbps</p>\n<p>- 하드웨어(서버)는 500대 이상</p>\n</blockquote>\n<p>100만 명 이상의 사용자들이 블로그를 쓰거나 북마크를 등록하고 있고, 월간 1,500만 명이 방문하고 있습니다. 이 방문자 수에 의해 월간 수십억 액세스가 발생합니다. 이 정도의 액세스가 되면 일일 액세스 로그는 기본적으로 기가바이트(gigabyte) 크기가 되며, DB 서버가 저장하는 데이터 규모도 대략 기가바이트 수준, 많을 때는 테라바이트(terabyte ) 정도가 됩니다.</p>\n<p>물리적으로 한대의 서버 내에 복수의 호스트가 가동되고 있으므로, 500대 규모의 물리적 서버가 존재한다면 결과적으로 1,000대 이상의 호스트를 가지게 됩니다. 이정도 규모에서는 호스트 정보를 관리하기 위한 툴 등이 필요해집니다.</p>\n<p>서비스의 규모는 서버대수 등으로 개략적으로 파악되는 경우가 많은데, 이런 관점에서 볼 때 백 대에서 수천 대 정도가 대규모 서비스라고 할 수 있습니다.</p>\n<p>Google 및 해외에서 인기 있는 SNS로 최근 구글의 트래픽을 앞지른 전례가 있는 페이스북과 같은 세계 Top 클래스 사이트는 서버 대수가 수백만 대 규모이고, 처리하는 데이터는 테라바이트~페타바이트(petabyte)급의 초대규모 서비스입니다.</p>\n<p><strong>소규모 서비스와 대규모 서비스의 차이</strong></p>\n<hr>\n<p>서버 몇 대 정도의 소규모 서비스에는 없는, 대규모 서비스에만 있는 문제나 어려움이 있으며 그 내용은 다음과 같습니다.</p>\n<p><strong>1. 확장성 확보, 부하분산 필요</strong></p>\n<p>대량의 액세스가 있는 서비스에서는 <strong>서버 1대로 처리할 수 없는 부하를 어떻게 처리할 것인지가 가장 큰 문제입니다. '스케일아웃(scale-out)'이 이 문제에 대한 전략의 기초가 됩니다.</strong> 스케일아웃은 서버를 횡적으로 전개, 서버의 역할을 분담하거나 대수를 늘림으로써 시스템의 전체적인 처리능력을 높여서 부하를 분산하는 방법입니다. 반면 '스케일업(scale-up)'은 하드웨어의 성능을 높여 처리능력을 끌어올리는 방법입니다.</p>\n<p>저가의 하드웨어를 횡으로 나열해서 확장성을 확보하는 것이 스케일아웃 전략입니다. 스케일아웃 전략을 채용한 경우는 비용이 절감되는 반면 다양한 문제가 발생합니다. 서버가 1대였을 때에는 전혀 생각지 않아도 될 문제입니다.</p>\n<p><strong>1) 사용자로부터 요청을 어떻게 분배할 것인가?</strong></p>\n<p>해답으로는 로드밸런서를 사용한다는 것인데, 서버 1대일 때에는 애초에 로드밸런서를 도입하는 것 자체를 생각할 필요도 없습니다.</p>\n<p><strong>2) 데이터 동기화는 어떻게 할 것인가?</strong></p>\n<p>DB를 분산시켰을 때 한쪽에 저장된 갱신 내용을 다른 한쪽 DB가 알지 못한다면 애플리케이션에 비정상 사태가 발생합니다.</p>\n<p><strong>3) 네트워크 통신의 지연시간(latency)를 어떻게 생각해 볼 수 있을까?</strong></p>\n<p>작은 데이터라도 이더넷(Ethernet)을 경유해서 통신한 경우는 밀리초(ms) 단위의 지연시간이 있습니다. 밀리초라고 하면 사람이 체감하기로는 그다지 긴 시간이 아니더라도 마이크로초나 나노초에 작동하는 컴퓨터에 있어서는 매우 긴 시간입니다. 통신의 오버헤드를 최소한으로 줄여가면서 애플리케이션을 구성해갈 필요가 있습니다.</p>\n<p><strong>2. 다중성 확보</strong></p>\n<p>스케일아웃을 해서 서버 대수가 늘어나면 서버의 고장률도 필연적으로 올라가게 됩니다. 그러므로 어딘가 잘못되면 서비스가 전부 정지해버리는 설계는 24시간 365일 계속 가동되어야 하는 웹서비스에서는 도저히 용납할 수 없습니다. 서버가 고장나더라도 혹은 급격하게 부하가 올라갈 경우에도 견딜 수 있는 시스템을 구성할 필요가 있습니다. 서비스가 대규모화되면 될수록 시스템 정지의 사회적 충격도 늘어나므로 더욱더 다중성 확보가 중요해집니다.</p>\n<p>2001년 9월, 미국 동시다발적인 테러 발생 상황을 알고자 사람들이 일제히 야후에 액세스해서 야후 Top 페이지가 다운돼버리는 사태가 일어났다고 합니다. 야후는 이때 CDN 서비스인 Akamai에 컨텐츠를 캐싱해서 트래픽을 우회시킴으로써 장애를 복구했다고 합니다.</p>\n<p>웹 서비스는 언제 어떠한 경우라도 고장에 대해 견고해야 합니다. 이는 상당히 어려운 과제인데, 시스템이 고장나면 그걸로 끝이어도 괜찮은 시스템 구축과 고장 나더라도 다른 시스템이 자동적으로 처리를 인계받는 시스템 구축 간에는 기술적으로나 비용면에서 상당히 큰 차이가 있습니다.</p>\n<p><strong>3. 효율적 운용 필요</strong></p>\n<p>서버가 1대라면 때때로 상태를 확인하는 정도로 서버가 정상적으로 동작하고 있는지를 간단하게 파악할 수 있을 것입니다. 반면 서버 대수가 100대를 넘어서면 어떤 서버가 무슨 역할을 하고 있는지 등에 대한 관리가 어려워집니다. 부하는 괜찮은지, 고장 난 부분은 없는지, 디스크 용량은 아직 충분한지, 보안설정에 미비한 점은 없는지 등등... 이를 모든 서버에 대해 여기저기 잘 살펴야 합니다.</p>\n<p>이에 대한 해결 방안으로 <strong>소프트웨어를 사용하고 정보관리를 위한 툴을 사용하는 등 자동화를 하게 됩니다.</strong> 그러나 이 감시 소프트웨어를 설치하거나 정보를 보는 것은 결국 인간입니다. 대규모 시스템을 건강한 상태로 얼마나 계속 유지해갈 수 있을 것인가? 이를 위한 효율적 운용을 수행해야 합니다.</p>\n<p><strong>4. 개발자 수, 개발방법의 변화</strong></p>\n<p>대규모 서비스가 되면 당연히 혼자서는 개발이나 운용이 어려워지므로 여러 기술자가 역할을 분담하게 됩니다. 애플리케이션을 각각의 기술자가 제멋대로 구현한 시스템의 전말을 생각하고 싶지 않습니다.</p>\n<p><strong>프로그래밍 언어를 통일하고, 라이브러리나 프레임워크를 통일하고, 코딩 규약을 정해서 표준화하고, 소스코드 관리를 버전관리 시스템으로 제대로 하는 등 이러한 사항들이 올바르게 실행되기 시작해야 여러 사람이 작업할 때 좋은 효율이 나타납니다.</strong> 여러 사람이 제각기 작업해서는 사람이 늘어나도 생산성은 오르지 않습니다.</p>\n<p><strong>대규모 데이터량에 대한 대처</strong></p>\n<hr>\n<p>컴퓨터는 디스크에서 데이터를 로드해서 메모리에 저장, 메모리에 저장된 데이터를 CPU가 fetch해서 특정 처리를 수행합니다. 또한 메모리에서 패치된 명령은 보다 빠른 캐시 메모리에 캐싱됩니다. 이처럼 데이터는 <strong>디스크→메모리→캐시 메모리→CPU</strong>와 같이 몇 단계를 경유해서 처리 되어 갑니다.</p>\n<p>각 단계 간에는 속도차는 매우 크게 나는 것이 현대 컴퓨터의 특징입니다. 하드디스크에서 데이터를 읽어들이는 데에는 그 특성상 헤드 이동이나 디스크 원반의 회전이라는 물리적 동작이 수반됩니다. 따라서 전기적으로 읽어들이기만 하면 되는 메모리나 캐시 메모리와 비교하면 10^6~10^9배나 되는 속도차가 나게 됩니다.</p>\n<p>이 속도차를 흡수하기 위해 OS는 이런저런 방법을 사용하게 됩니다. 예를 들면 디스크로부터 읽어들인 데이터를 메모리에 캐싱해둠으로써 전반적으로 디바이스간 속도차가 체감속도에 영향을 주지 않도록 하고 있습니다. DB를 비롯한 미들웨어도 기본적으로 이러한 속도차를 의식한 데이터 구조, 구현을 채용하고 있습니다.</p>\n<p>하지만 OS나 미들웨어 등의 소프트웨어에서 이런 구조를 통해 분발한다고해도 당연히 한계는 있습니다. 데이터량이 많아지면 처음부터 캐시 미스(cache miss)가 많이 발생하게 되고, 그 결과로 저속의 디스크로의 I/O가 많이 발생하게 됩니다. 디스크 I/O 대기에 들어선 프로그램은 다른 리 소스가 비어 있더라도 읽기가 완료되기까지는 다음 처리를 수행할 수가 없습니다. 이것이 시스템 전체의 속도저하를 초래합니다.</p>\n<p>대규모 웹 애플리케이션을 운용할 때 대부분의 어려움은 이러한 대규모 데이터 처리에 집중됩니다.</p>\n<p>데이터가 적을 때에는 특별히 고민하지 않아도 모두 메모리에서 처리할 수 있으며, 복잡한 알고리즘을 사용하기보다 간단한 알고리즘을 사용하는 편이 오버헤드가 적기 때문에 더 빠른 경우도 종종 있으므로 I/O 부하는 일단 문제가 되지 않습니다. <strong>그러나 서비스가 어느 정도 이상의 규모가 되면 데이터는 증가합니다. 이 데이터량이 분수령을 넘어서면 문제가 복잡해집니다. 그리고 응급처리로는 쉽사리 풀리지 않습니다. 이 점이 대규모 서비스의 어려운 점입니다.</strong></p>\n<p>어떻게 하면 데이터를 적게 가져갈 수 있을까. 여러 서버로 분산시킬 수 있을까, 필요한 데이터를 최소한의 횟수로 읽어들일 수 있을까 등등.. 이것이 본질적인 과제가 됩니다.</p>\n<p><strong>시스템 규모확장에서의 시행착오</strong></p>\n<hr>\n<p>하테나의 규모확장에 대한 대처는 시행착오의 연속이였다고 합니다. 먼저 라우터는 Linux 박스로 저가에 구축, HTTP 요청 분산은 아파치의 mod_rewrite로 대용, DB분산은 MySQL의 레플리케이션 기능을 사용하기 시작하다 블로그 붐이 일어나며 트래픽 증가에 비해 시스템 확장이 따라가지 못하게 되었습니다. 당시는 분산뿐 아니라 다중화, 효율적 운용면에서도 미비한 점이 많았는데, 다중화된 시스템이 자동으로 가동되는 것이 아니라 근처에 살고 있는 엔지니어가 알아차리고 Hang-Up된 서버를 재기동하는 등의 응급처치로 견뎌냈습니다.</p>\n<p>이후 트래픽이 지속적으로 증가하면서, 임대해서 쓰던 작은 서버룸이 서버 증설에 따라 전력이 부족하게 되면서 더이상 서버를 추가할 수 없는, 추가하게 되면 전류 차단기가 내려가버리게 되는 상황에 처하게 되었습니다.</p>\n<p><strong>데이터 센터로의 이전, 시스템 쇄신</strong></p>\n<hr>\n<p>더이상 손쓸 방법이 없는 상황이 되어서야 조직체제를 재점검하고 시스템 운용 전담팀을 구성하여 대응에 임했다고 합니다. 이때부터 1년에 걸쳐 작은 서버 룸에서 인터넷 데이터 센터로 서버를 이전하는 작업을 시작했습니다. 이전 작업을 하면서 네트워크 설계를 근본적으로 재수정하고 낡은 서버는 모두 교체하는 방침을 채택했습니다.</p>\n<p>우선은 사전에 기존 시스템의 부하상황을 정리했습니다. 이 정보를 활용해서 각 서비스의 구성 중에 병목지점을 측정, 판정하고 I/O 부하가 높은 서버는 메모리를 중요시하고 CPU 부하가 높은 서버는 CPU를 중요시하는 형태로 서버 용도에 맞게 최적의 구성을 갖는 하드웨어를 준비해갔습니다.</p>\n<p>다중화의 경우 로드밸런서 +가동감시 기능을 하는 오픈소스 소프트웨어인 LVS + keepalived를 도입했으며, 이에 따라 Linux 박스로 저가에 구축한 로드밸런서를 각 부문에 도입함으로써 차츰 개선해 나갔습니다. 서버 교체에 있어서는 서서히 OS 가상화도 진행해서 서버 가동률을 높임과 동시에 유지보수성을 높여 갔습니다.</p>\n<p>서버의 정보관리를 위해 독자적인 웹 기반 서버 정보관리 시스템도 개발하였으며, 이에 따라 서버의 용도나 부하상태와 같은 각종 정보에 액세스하기 쉬워져서 시스템 전체를 파악하기 용이해졌습니다.</p>\n<p>서버/인프라 측면의 시스템 구성뿐만 아니라 애츨리케이션의 각종 로직이나 DB 스키마 등도 재검토해서 비효율적인 부문을 서서히 배제해갔습니다. 필요에 따라 검색 엔진 등의 서브시스템을 독자 개발하는 경우도 있었습니다.</p>\n<p>그러나 시스템이 안정되었다고해도 거기서 멈춰버리는 것이 아니라 결국 그 이후의 성장을 위해서는 다시 예전과 동일한 작업을 반복해야만 합니다. 그러지 않기 위해 현재도 개발 담당, 인프라 담당이 하나가 되어 밤낮없이 시스템 품질개선을 수행을 진행 중입니다.</p>\n<p><strong>대규모 서비스에서 기술팀</strong></p>\n<hr>\n<p>대규모 서비스에서 서비스 개발부는 각종 서비스 구현을 담당하며, 매일 애플리케이션 측면의 개선을 담당합니다. 서버/인프라 시스템은 1,000대 규모의 호스트를 보유하는 큰시스템이므로 전담팀이 그 운용을 담당하게 되는데, 고장, 과부하, 설정미비, 노후화로 인한 교체 등등. 이런 문제들을 전담해서 맡으면서 가상화나 클라우드 등 보다 세련된 새로운 모습으로 시스템을 확장해 가는 것도 인프라부의 일입니다. 서비스 개발부는 서버/인프라 시스템이 지탱하는 기반 위에 서비스를 개발합니다. 부하 상황은 서버/인프라팀이 감시하고 있고, 인프라 부분의 개선으로 대처할 수 있는 문제는 그들이 즉시 대응하게 되지만, 애플리케이션에 원인이 있는 경우 등 구현이 관련된 경우에는 서비스 개발부와 협력해서 대응합니다.</p>\n<p>서비스발부에서도 담당하고 있는 서비스의 성능을 트래킹하고 있으며, 주요한 페이지가 어느 정도의 응답시간에 응답하고 있느지를 정량화해서 매일 그것을 지표로 한계값(threshold)를 밑돌지 않도록 목표를 설정한 개선을 진행합니다.</p>\n<blockquote>\n<p><strong>엔지니어가 개발에 사용하고 있는 툴의 종류</strong></p>\n<p>- 프로그래밍 언어</p>\n<p>- 주요 미들웨어</p>\n<p>- 웹 애플리케이션 프레임워크</p>\n<p>- 주위 머신의 OS 및 에디터</p>\n<p>- 버전관리, BTS(Bug Tracking System, 버그추적 시스템)</p>\n</blockquote>"},{"frontmatter":{"tags":["고성능 아키텍쳐"],"title":"왓츠앱만들기"},"internal":{"content":"\n# 왓츠앱만들기\n\n---\n\ntitle: \"왓츠앱만들기\"\ncategory: \"고성능 아키텍쳐\"\ncover: architecture.jpg\nauthor: Athi\n\n---\n\n[참고자료](https://hackernoon.com/how-to-build-your-own-real-time-chat-app-like-whatsapp-9d1d058afd5b)\n\n# **WhatsApp 와 같은 실시간 채팅 응용 프로그램을 만드는 방법은 무엇입니까?**\n\n![](https://cdn-images-1.medium.com/freeze/max/30/1*mLE5ZxhtATxrwh20SL2Tlg.png?q=20)\n\n![](https://cdn-images-1.medium.com/max/800/1*mLE5ZxhtATxrwh20SL2Tlg.png)\n\n![](https://cdn-images-1.medium.com/max/800/1*mLE5ZxhtATxrwh20SL2Tlg.png)\n\nWhatsApp 와 같은 앱을 만드는 것은 엄청난 아이디어입니다. 그러나이를 구현하는 데 사용 된 기술과 기능을 알아야합니다.\n\n이제 첫 번째 대화방이 작은 대화를 유도하는 사람들을 유혹했을 때 다시 생각해보십시오. 그런 다음, 소셜 네트워킹 사이트는 지평선 연결을 제공하기 위해 평범한 삶을 뚫었습니다. 잠시 후 인스턴트 메시징을 사용하면 신속한 대응을 통해 우리를 계속 참여시킬 수 있습니다. 또한 인스턴트 메시징 앱이 제공하는 편리함과 편안함을 위해 가을을 높였습니다.\n\n우리는 Whatsapp 과 같은 채팅 앱에 대해 많은 관심을 보이면서 인기가 급상승했습니다. 대부분의 사람들은 사용자에게 개인적인 터치 경험을 추가하는 실시간 상호 작용을 제공하는 채팅 앱을 개발하는 것을 선호한다는 사실이 밝혀졌습니다.\n\n이제는 소매를 걷어 올려 WhatsApp 와 같은 또 다른 엄청난 채팅 앱을 개발할 때가되었습니다.\n\n## **현대 채팅 앱의 진화**\n\n보기에 현대의 채팅 앱은 모든 유형의 채팅 솔루션에 적용 할 수있는 주목할만한 기능을 갖추고 있어야합니다. 최근에는 WhatsApp 회사와 같은 채팅 앱을 만들어 인공 지능과 봇 (Bots)과 같은 헤드 웨이 기술을 실험하는 것으로 나타났습니다. 이상적인 채팅 앱은 엔터프라이즈 급 커뮤니케이션, 개인 채팅, 비즈니스 개발 커뮤니케이션 및 전자 상거래 채팅 솔루션에 대한 솔루션을 제공 할 수있는 잠재력이 있습니다.\n\n이후 WhatsApp 의 성공으로 인해 투자자와 개발자가 WhatsApp 의 성공을 모색하는 것은 놀라운 일이 아닙니다. 동일하게 콘서스 의 핵심 제품은 WhatsApp 와 같은 채팅 앱을 개발할 수있는 포괄적 인 기술을 보유하고있다. [**Contus Fly**](http://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&utm_medium=InContentLink&utm_campaign=Hackernoon) 는 Android 및 iOS 와 같은 다양한 플랫폼에서 기대하는 바에 따라 새로운 기능을 끌어 들인다. WhatsApp 는 메시징 시장을 여전히 운영 할 수 있지만 WhatsApp 이 가지고 있지 않은 특정 기능을 번성시키는 채팅 응용 프로그램을위한 공간이 있습니다.\n\n귀하의 객관적인 사업을 고려할 때, 그것은 WhatsApp 의 전통적인 버전을 개발하는 것이 아니라 사용자가 분명히 식별하고 모든 채팅 솔루션에 이상적인 현대적인 채팅 응용 프로그램을 구축하는 것으로 끝납니다.\n\n## **WhatsApp 와 같은 훌륭한 채팅 응용 프로그램을 만들기 위해 어떤 기술이 완벽하게 구현되었는지 궁금한 적이 있습니까?**\n\nContus Fly 가 백엔드 구성 요소를 갖춘 아키텍처로 Whatsapp 와 유사한 실시간 채팅 앱을 만들 수 있습니다.\n\n**Erlang :** Epic 채팅 앱 Whatsapp 을 개발하는 데 사용 된 주요 프로그래밍 언어입니다. Erlang 프로그래밍 언어는 성능상의 이유, 속도 및 확장 성으로 인해 높이 평가되었습니다. Contus Fly 는 가비지 컬렉터가 다양한 기능 최적화를 위해 즉시 코드를 업데이트 할 수 있도록하는 Erlang 을 기반으로합니다. Contus Fly 에서 구현 된 프로그래밍 언어는 매우 짧은 대기 시간으로 많은 양의 짧은 메시지 처리 기능을 제공합니다.\n\n**Ejabberd :** Contus Fly 는 예상 결과에 최적화 된 운영 효율성을 향상시키기 위해 오픈 소스 jabber 유사 (WhatsApp 복제)를 사용합니다. XMPP (Extensible Messaging and Presence Protocol) 프로토콜을 사용하여 로컬 영역 네트워크 또는 인터넷상의 메시지 전달 시스템을 처리합니다. Ejabberd 서버는 다음과 같은 다양한 기능을 가능하게하는 특정 플러그 가능한 모듈을 사용하여 개발되었습니다.\n\n1.  일대일 채팅\n2.  실제 및 현재 업체 정보에 문의\n3.  저장 및 전달 (오프라인 메시지)\n4.  개인 이벤트 프로토콜 (PEP) 및 메시지 유형 지정\n5.  다중 사용자 채팅 (MUC) \\- 그룹 채팅\n6.  개인 정보 설정 및 계정 스푸핑\n7.  메시지 아카이브 관리 (MAM)\n\n**FreeBSD :** 매일 플랫폼에 수십억 개의 메시지를 보냈던 WhatsApp 은 FreeBSD 를 기반으로 구축되었습니다. Contus Fly 는 섬세한 네트워크 스택과 광범위한 신뢰성으로 인해 FreeBSD 운영 체제를 선택했습니다. 단일 배포자인 FreeBSD 는 설치에 많은 이점을 가지고 있고 바이너리 패키지를 쉽게 만들 수 있습니다.\n\n**YAWS :** (또 다른 웹 서버)는 완전히 Erlang 으로 작성되었습니다. Contus Fly 는 YAWS 가 다른 Erlang 어플리케이션의 조합에 내장 웹 서버로 실행되는 내장 모드를 사용합니다. YAWS 시스템은 동시 프로세스를 효율적으로 처리 할 수 ​​ 있고 고성능을 보유합니다.\n\n**Lighttpd :** Lighttpd 는 고성능을 위해 Contus Fly 용으로 최적화 된 오픈 소스 웹 서버입니다. Lightweight 웹 서버는 WhatsApp 에 배포되어 안전하고 유연하며 신속하고 호환되는 기능을 제공합니다.\n\n**PHP :** 성능과 안정성을 위해 PHP 오픈 소스 언어를 사용하는 Contus Fly. Ajax 를 사용하여 데이터베이스의 데이터를 표시하는 강력한 웹 개발 기술로 반응 형 실시간 채팅 앱을 개발할 수 있습니다.\n\n**BEAM :** 빔은 Erlang 을 실행하는 가상 머신입니다. if\\-simple 네트워크 인터페이스 도구와 같은 내장 된 기능들이 많이 있습니다. Contus Fly 는 BEAM 인터페이스를 사용하여 스케줄러, 프로세스, 메시지 전달, 메모리 관리 및 멀티 코어 등의 기능을 지원합니다.\n\n**사용자 정의 XMPP 서버 :** Contus 키워드의 바이트를 줄임으로써 인코딩 된 XMPP 서버를 해당 기능으로 이동합니다. 이 기술은 실시간으로 메시지를 교환하는 데 사용됩니다. XML 형식은 인간 중심적이며 모든 기계 학습에서 읽을 수있는 형식이 아닙니다.\n\n![](https://cdn-images-1.medium.com/freeze/max/30/1*BJciiUkXUQ2lqjGxXcRu_g.png?q=20)\n\n![](https://cdn-images-1.medium.com/max/800/1*BJciiUkXUQ2lqjGxXcRu_g.png)\n\n![](https://cdn-images-1.medium.com/max/800/1*BJciiUkXUQ2lqjGxXcRu_g.png)\n\n**HTML5 WebSockets :** WebSocket 은 웹 브라우저와 서버 사이의 견고한 연결을 설정하는 데 사용되는 HTML5 의 기능입니다. WebSocket 데이터는 서버와 웹 브라우저간에 더 빠르고 지속적인 통신을 제공하는 소켓을 통해 직접 전송됩니다.\n\n**Mnesia DB :** Erlang 언어로 작성된 실시간 데이터베이스 관리 시스템입니다. Contus Fly 는 메시지, 파일, 이미지, 비디오, 문서 및 앱에서 실행되는 나머지 멀티미디어 파일을 저장할 수있는 소프트 데이터베이스 인 Mnesia 를 사용합니다. 이는 어느 정도의 데이터를 저장할 가능성이있는 사용자의 기대를 뛰어 넘는 일종의 기술입니다.\n\n[![](https://cdn-images-1.medium.com/max/800/1*IBQbVNnmdK20_n0ibWWQtA.png)](https://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&utm_medium=InContentLink1&utm_campaign=Hackernoon)\n\n업데이트 얻기\n\n## 채팅 응용 프로그램의 성공적인 기능 :\n\n이제 포괄적 인 채팅 앱에서 제공하는 내장 된 기능을 잘 살펴 보겠습니다.\n\n**#1. VOIP 전화 통화 :**\nVOIP (Voice Over Internet Protocol)는 인터넷 프로토콜을 통해 음성 통신 및 멀티미디어 세션을 제공하는 기술을 분류 한 것입니다.\n\n**\\# 2. 비디오 채팅 :**\n중간에 연결하지 않고 직접 전화를 걸어 음성 / 영상으로 개인 터치 경험을 통해 대화 할 수 있습니다.\n\n**#삼. 그룹 통화 :**\n채팅 앱을 통해 사용자는 비디오 / 오디오를 통한 그룹 대화를 용이하게하면서 다른 사용자와 더 연결할 수 있습니다.\n\n**\\# 4. 종단 간 채팅 암호화 :**\n타사 침입으로부터 사용자 안전 암호화. 고급 프리미엄 암호화 기술을 통해 사용자 개인 데이터 보안의 우선 순위를 지정하십시오.\n\n**\\# 5. Cloud Service Sync :**\n클라우드 리소스 플랫폼 동기화를 통해 호스팅 환경을 모니터링, 업데이트, 저장 및 확장 할 수 있습니다.\n\n**\\# 6. 멀티미디어 지원 :**\n비디오, 이미지, GIF, 음성 메모, 애니메이션, 문서, 연락처 및 위치와 같은 다양한 데이터 형식의 파일 전송.\n\n**\\# 7. 자기 파괴 메시지 :**\n다른 사람이 메시지를 볼 수없는 그룹의 수신자 이름을 두드려 속삭임을 보낼 수 있습니다.\n\n**\\# 8. 지리적 위치 통합 :**\n향상된 지리적 위치 통합은 실시간 기반의 효과적인 상호 작용 흐름을 만듭니다.\n\n**\\# 9. 캘린더 동기화 :**\n캘린더 동기화는 아직 계획하지 않은 일정과 작업에 대한 철저한 지식을 제공합니다.\n\n**\\# 10. 다중 플랫폼 채팅 :**\n교차 플랫폼 메시징을 통해 책상에서 또는 이동 중에도 손쉽게 도달 할 수 있습니다.\n\n**\\# 11. 인앱 구매 : 앱**\n수익 창출을 위해 디지털 스토어에서 앱을 판매하려면 올바른 수익 창출 전략을 선택하십시오.\n\n**\\# 12. 지불 통합 :**\n\n**UPI**  \\- 통합 지불 인터페이스는보다 안전하고 사용자에게 친숙하며 즉석 지불을 허용하는 지불 모듈 중 하나입니다.\n\n**VPA**  \\- 가상 지불 주소는 은행 계좌 번호 및 IFSC 코드 대신 공개적으로 공유 할 수있는 특정 은행 계좌에 등록 된 이메일 주소를 사용합니다.\n\n**MPIN**  \\- 모바일 뱅킹 개인 식별 번호는 UPI 를 통해 이전 된 모든 유형의 돈을 인증하는 데 사용되는 4\\-6 자리 보안 코드입니다\n\n## WhatsApp 에없는 동적 기능 :\n\n이러한 내장 기능 외에도 Contus Fly 는 사용자의 기대와 유형에 따라 기능을 넘어 통합 할 수 있습니다.\n\n1.  **사용자 액세스 구성 및 사용자 계정 관리 :**\n    \\-> 사용자 초대 만\n    \\-> 공개 액세스\n    \\-> 관리자 인증 액세스\n2.  **원하는 플랫폼을 통해 알림을 통해 활성 사용자의 참여 유도 :**\n    \\-> 푸시 알림\n    \\-> 이메일 및 이메일 요약\n    \\-> SMS\n3.  **필요에 따라 맞춤 채팅 그룹 만들기 :**\n    \\-> 모든 사용자가\n    그룹을 만들 수 있음 \\-> 관리자 만 그룹을 만들 수 있음\n    \\-> 사용자가 그룹에 가입하고\n    볼 수 있음 \\-> 사용자는 관련 서클에없는 그룹을 볼 수 없음\n\n## Contus Fly 는 채팅 앱 솔루션의 수익 창출을 통해 귀하의 머니를 만드는데 다양한 기능을 제공합니다.\n\n![](https://cdn-images-1.medium.com/freeze/max/30/1*gqjHqYySlGsuL9gs7P54Zg.png?q=20)\n\n![](https://cdn-images-1.medium.com/max/800/1*gqjHqYySlGsuL9gs7P54Zg.png)\n\n![](https://cdn-images-1.medium.com/max/800/1*gqjHqYySlGsuL9gs7P54Zg.png)\n\n1\\. 완전히 무료\n2\\. 인앱 결제\n3\\. 모바일 광고\n4\\. 스폰서\n5\\. 구독\n\n> **\"모든 새로운 친구 (채팅 앱)는 미래에도 여전히 여유가 있습니다.\"**\n\n당신이하려고하면 [**채팅 응용 프로그램을 구축**](http://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&utm_medium=CTA&utm_campaign=Hackernoon) WhatsApp 에 같이 추가 현대적인 기능 향상, 당신은 동적 기능을 사용하여 채팅 응용 프로그램을 가지고 옳은 길이다.\n"},"html":"<h1 id=\"왓츠앱만들기\" style=\"position:relative;\"><a href=\"#%EC%99%93%EC%B8%A0%EC%95%B1%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"왓츠앱만들기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왓츠앱만들기</h1>\n<hr>\n<p>title: \"왓츠앱만들기\"\ncategory: \"고성능 아키텍쳐\"\ncover: architecture.jpg\nauthor: Athi</p>\n<hr>\n<p><a href=\"https://hackernoon.com/how-to-build-your-own-real-time-chat-app-like-whatsapp-9d1d058afd5b\">참고자료</a></p>\n<h1 id=\"whatsapp-와-같은-실시간-채팅-응용-프로그램을-만드는-방법은-무엇입니까\" style=\"position:relative;\"><a href=\"#whatsapp-%EC%99%80-%EA%B0%99%EC%9D%80-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%B1%84%ED%8C%85-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C\" aria-label=\"whatsapp 와 같은 실시간 채팅 응용 프로그램을 만드는 방법은 무엇입니까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>WhatsApp 와 같은 실시간 채팅 응용 프로그램을 만드는 방법은 무엇입니까?</strong></h1>\n<p><img src=\"https://cdn-images-1.medium.com/freeze/max/30/1*mLE5ZxhtATxrwh20SL2Tlg.png?q=20\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*mLE5ZxhtATxrwh20SL2Tlg.png\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*mLE5ZxhtATxrwh20SL2Tlg.png\" alt=\"\"></p>\n<p>WhatsApp 와 같은 앱을 만드는 것은 엄청난 아이디어입니다. 그러나이를 구현하는 데 사용 된 기술과 기능을 알아야합니다.</p>\n<p>이제 첫 번째 대화방이 작은 대화를 유도하는 사람들을 유혹했을 때 다시 생각해보십시오. 그런 다음, 소셜 네트워킹 사이트는 지평선 연결을 제공하기 위해 평범한 삶을 뚫었습니다. 잠시 후 인스턴트 메시징을 사용하면 신속한 대응을 통해 우리를 계속 참여시킬 수 있습니다. 또한 인스턴트 메시징 앱이 제공하는 편리함과 편안함을 위해 가을을 높였습니다.</p>\n<p>우리는 Whatsapp 과 같은 채팅 앱에 대해 많은 관심을 보이면서 인기가 급상승했습니다. 대부분의 사람들은 사용자에게 개인적인 터치 경험을 추가하는 실시간 상호 작용을 제공하는 채팅 앱을 개발하는 것을 선호한다는 사실이 밝혀졌습니다.</p>\n<p>이제는 소매를 걷어 올려 WhatsApp 와 같은 또 다른 엄청난 채팅 앱을 개발할 때가되었습니다.</p>\n<h2 id=\"현대-채팅-앱의-진화\" style=\"position:relative;\"><a href=\"#%ED%98%84%EB%8C%80-%EC%B1%84%ED%8C%85-%EC%95%B1%EC%9D%98-%EC%A7%84%ED%99%94\" aria-label=\"현대 채팅 앱의 진화 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>현대 채팅 앱의 진화</strong></h2>\n<p>보기에 현대의 채팅 앱은 모든 유형의 채팅 솔루션에 적용 할 수있는 주목할만한 기능을 갖추고 있어야합니다. 최근에는 WhatsApp 회사와 같은 채팅 앱을 만들어 인공 지능과 봇 (Bots)과 같은 헤드 웨이 기술을 실험하는 것으로 나타났습니다. 이상적인 채팅 앱은 엔터프라이즈 급 커뮤니케이션, 개인 채팅, 비즈니스 개발 커뮤니케이션 및 전자 상거래 채팅 솔루션에 대한 솔루션을 제공 할 수있는 잠재력이 있습니다.</p>\n<p>이후 WhatsApp 의 성공으로 인해 투자자와 개발자가 WhatsApp 의 성공을 모색하는 것은 놀라운 일이 아닙니다. 동일하게 콘서스 의 핵심 제품은 WhatsApp 와 같은 채팅 앱을 개발할 수있는 포괄적 인 기술을 보유하고있다. <a href=\"http://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&#x26;utm_medium=InContentLink&#x26;utm_campaign=Hackernoon\"><strong>Contus Fly</strong></a> 는 Android 및 iOS 와 같은 다양한 플랫폼에서 기대하는 바에 따라 새로운 기능을 끌어 들인다. WhatsApp 는 메시징 시장을 여전히 운영 할 수 있지만 WhatsApp 이 가지고 있지 않은 특정 기능을 번성시키는 채팅 응용 프로그램을위한 공간이 있습니다.</p>\n<p>귀하의 객관적인 사업을 고려할 때, 그것은 WhatsApp 의 전통적인 버전을 개발하는 것이 아니라 사용자가 분명히 식별하고 모든 채팅 솔루션에 이상적인 현대적인 채팅 응용 프로그램을 구축하는 것으로 끝납니다.</p>\n<h2 id=\"whatsapp-와-같은-훌륭한-채팅-응용-프로그램을-만들기-위해-어떤-기술이-완벽하게-구현되었는지-궁금한-적이-있습니까\" style=\"position:relative;\"><a href=\"#whatsapp-%EC%99%80-%EA%B0%99%EC%9D%80-%ED%9B%8C%EB%A5%AD%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%96%B4%EB%96%A4-%EA%B8%B0%EC%88%A0%EC%9D%B4-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%97%88%EB%8A%94%EC%A7%80-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%81%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EA%B9%8C\" aria-label=\"whatsapp 와 같은 훌륭한 채팅 응용 프로그램을 만들기 위해 어떤 기술이 완벽하게 구현되었는지 궁금한 적이 있습니까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>WhatsApp 와 같은 훌륭한 채팅 응용 프로그램을 만들기 위해 어떤 기술이 완벽하게 구현되었는지 궁금한 적이 있습니까?</strong></h2>\n<p>Contus Fly 가 백엔드 구성 요소를 갖춘 아키텍처로 Whatsapp 와 유사한 실시간 채팅 앱을 만들 수 있습니다.</p>\n<p><strong>Erlang :</strong> Epic 채팅 앱 Whatsapp 을 개발하는 데 사용 된 주요 프로그래밍 언어입니다. Erlang 프로그래밍 언어는 성능상의 이유, 속도 및 확장 성으로 인해 높이 평가되었습니다. Contus Fly 는 가비지 컬렉터가 다양한 기능 최적화를 위해 즉시 코드를 업데이트 할 수 있도록하는 Erlang 을 기반으로합니다. Contus Fly 에서 구현 된 프로그래밍 언어는 매우 짧은 대기 시간으로 많은 양의 짧은 메시지 처리 기능을 제공합니다.</p>\n<p><strong>Ejabberd :</strong> Contus Fly 는 예상 결과에 최적화 된 운영 효율성을 향상시키기 위해 오픈 소스 jabber 유사 (WhatsApp 복제)를 사용합니다. XMPP (Extensible Messaging and Presence Protocol) 프로토콜을 사용하여 로컬 영역 네트워크 또는 인터넷상의 메시지 전달 시스템을 처리합니다. Ejabberd 서버는 다음과 같은 다양한 기능을 가능하게하는 특정 플러그 가능한 모듈을 사용하여 개발되었습니다.</p>\n<ol>\n<li>일대일 채팅</li>\n<li>실제 및 현재 업체 정보에 문의</li>\n<li>저장 및 전달 (오프라인 메시지)</li>\n<li>개인 이벤트 프로토콜 (PEP) 및 메시지 유형 지정</li>\n<li>다중 사용자 채팅 (MUC) - 그룹 채팅</li>\n<li>개인 정보 설정 및 계정 스푸핑</li>\n<li>메시지 아카이브 관리 (MAM)</li>\n</ol>\n<p><strong>FreeBSD :</strong> 매일 플랫폼에 수십억 개의 메시지를 보냈던 WhatsApp 은 FreeBSD 를 기반으로 구축되었습니다. Contus Fly 는 섬세한 네트워크 스택과 광범위한 신뢰성으로 인해 FreeBSD 운영 체제를 선택했습니다. 단일 배포자인 FreeBSD 는 설치에 많은 이점을 가지고 있고 바이너리 패키지를 쉽게 만들 수 있습니다.</p>\n<p><strong>YAWS :</strong> (또 다른 웹 서버)는 완전히 Erlang 으로 작성되었습니다. Contus Fly 는 YAWS 가 다른 Erlang 어플리케이션의 조합에 내장 웹 서버로 실행되는 내장 모드를 사용합니다. YAWS 시스템은 동시 프로세스를 효율적으로 처리 할 수 ​​ 있고 고성능을 보유합니다.</p>\n<p><strong>Lighttpd :</strong> Lighttpd 는 고성능을 위해 Contus Fly 용으로 최적화 된 오픈 소스 웹 서버입니다. Lightweight 웹 서버는 WhatsApp 에 배포되어 안전하고 유연하며 신속하고 호환되는 기능을 제공합니다.</p>\n<p><strong>PHP :</strong> 성능과 안정성을 위해 PHP 오픈 소스 언어를 사용하는 Contus Fly. Ajax 를 사용하여 데이터베이스의 데이터를 표시하는 강력한 웹 개발 기술로 반응 형 실시간 채팅 앱을 개발할 수 있습니다.</p>\n<p><strong>BEAM :</strong> 빔은 Erlang 을 실행하는 가상 머신입니다. if-simple 네트워크 인터페이스 도구와 같은 내장 된 기능들이 많이 있습니다. Contus Fly 는 BEAM 인터페이스를 사용하여 스케줄러, 프로세스, 메시지 전달, 메모리 관리 및 멀티 코어 등의 기능을 지원합니다.</p>\n<p><strong>사용자 정의 XMPP 서버 :</strong> Contus 키워드의 바이트를 줄임으로써 인코딩 된 XMPP 서버를 해당 기능으로 이동합니다. 이 기술은 실시간으로 메시지를 교환하는 데 사용됩니다. XML 형식은 인간 중심적이며 모든 기계 학습에서 읽을 수있는 형식이 아닙니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/freeze/max/30/1*BJciiUkXUQ2lqjGxXcRu_g.png?q=20\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*BJciiUkXUQ2lqjGxXcRu_g.png\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*BJciiUkXUQ2lqjGxXcRu_g.png\" alt=\"\"></p>\n<p><strong>HTML5 WebSockets :</strong> WebSocket 은 웹 브라우저와 서버 사이의 견고한 연결을 설정하는 데 사용되는 HTML5 의 기능입니다. WebSocket 데이터는 서버와 웹 브라우저간에 더 빠르고 지속적인 통신을 제공하는 소켓을 통해 직접 전송됩니다.</p>\n<p><strong>Mnesia DB :</strong> Erlang 언어로 작성된 실시간 데이터베이스 관리 시스템입니다. Contus Fly 는 메시지, 파일, 이미지, 비디오, 문서 및 앱에서 실행되는 나머지 멀티미디어 파일을 저장할 수있는 소프트 데이터베이스 인 Mnesia 를 사용합니다. 이는 어느 정도의 데이터를 저장할 가능성이있는 사용자의 기대를 뛰어 넘는 일종의 기술입니다.</p>\n<p><a href=\"https://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&#x26;utm_medium=InContentLink1&#x26;utm_campaign=Hackernoon\"><img src=\"https://cdn-images-1.medium.com/max/800/1*IBQbVNnmdK20_n0ibWWQtA.png\" alt=\"\"></a></p>\n<p>업데이트 얻기</p>\n<h2 id=\"채팅-응용-프로그램의-성공적인-기능-\" style=\"position:relative;\"><a href=\"#%EC%B1%84%ED%8C%85-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%84%B1%EA%B3%B5%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5-\" aria-label=\"채팅 응용 프로그램의 성공적인 기능  permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>채팅 응용 프로그램의 성공적인 기능 :</h2>\n<p>이제 포괄적 인 채팅 앱에서 제공하는 내장 된 기능을 잘 살펴 보겠습니다.</p>\n<p><strong>#1. VOIP 전화 통화 :</strong>\nVOIP (Voice Over Internet Protocol)는 인터넷 프로토콜을 통해 음성 통신 및 멀티미디어 세션을 제공하는 기술을 분류 한 것입니다.</p>\n<p><strong># 2. 비디오 채팅 :</strong>\n중간에 연결하지 않고 직접 전화를 걸어 음성 / 영상으로 개인 터치 경험을 통해 대화 할 수 있습니다.</p>\n<p><strong>#삼. 그룹 통화 :</strong>\n채팅 앱을 통해 사용자는 비디오 / 오디오를 통한 그룹 대화를 용이하게하면서 다른 사용자와 더 연결할 수 있습니다.</p>\n<p><strong># 4. 종단 간 채팅 암호화 :</strong>\n타사 침입으로부터 사용자 안전 암호화. 고급 프리미엄 암호화 기술을 통해 사용자 개인 데이터 보안의 우선 순위를 지정하십시오.</p>\n<p><strong># 5. Cloud Service Sync :</strong>\n클라우드 리소스 플랫폼 동기화를 통해 호스팅 환경을 모니터링, 업데이트, 저장 및 확장 할 수 있습니다.</p>\n<p><strong># 6. 멀티미디어 지원 :</strong>\n비디오, 이미지, GIF, 음성 메모, 애니메이션, 문서, 연락처 및 위치와 같은 다양한 데이터 형식의 파일 전송.</p>\n<p><strong># 7. 자기 파괴 메시지 :</strong>\n다른 사람이 메시지를 볼 수없는 그룹의 수신자 이름을 두드려 속삭임을 보낼 수 있습니다.</p>\n<p><strong># 8. 지리적 위치 통합 :</strong>\n향상된 지리적 위치 통합은 실시간 기반의 효과적인 상호 작용 흐름을 만듭니다.</p>\n<p><strong># 9. 캘린더 동기화 :</strong>\n캘린더 동기화는 아직 계획하지 않은 일정과 작업에 대한 철저한 지식을 제공합니다.</p>\n<p><strong># 10. 다중 플랫폼 채팅 :</strong>\n교차 플랫폼 메시징을 통해 책상에서 또는 이동 중에도 손쉽게 도달 할 수 있습니다.</p>\n<p><strong># 11. 인앱 구매 : 앱</strong>\n수익 창출을 위해 디지털 스토어에서 앱을 판매하려면 올바른 수익 창출 전략을 선택하십시오.</p>\n<p><strong># 12. 지불 통합 :</strong></p>\n<p><strong>UPI</strong>  - 통합 지불 인터페이스는보다 안전하고 사용자에게 친숙하며 즉석 지불을 허용하는 지불 모듈 중 하나입니다.</p>\n<p><strong>VPA</strong>  - 가상 지불 주소는 은행 계좌 번호 및 IFSC 코드 대신 공개적으로 공유 할 수있는 특정 은행 계좌에 등록 된 이메일 주소를 사용합니다.</p>\n<p><strong>MPIN</strong>  - 모바일 뱅킹 개인 식별 번호는 UPI 를 통해 이전 된 모든 유형의 돈을 인증하는 데 사용되는 4-6 자리 보안 코드입니다</p>\n<h2 id=\"whatsapp-에없는-동적-기능-\" style=\"position:relative;\"><a href=\"#whatsapp-%EC%97%90%EC%97%86%EB%8A%94-%EB%8F%99%EC%A0%81-%EA%B8%B0%EB%8A%A5-\" aria-label=\"whatsapp 에없는 동적 기능  permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WhatsApp 에없는 동적 기능 :</h2>\n<p>이러한 내장 기능 외에도 Contus Fly 는 사용자의 기대와 유형에 따라 기능을 넘어 통합 할 수 있습니다.</p>\n<ol>\n<li><strong>사용자 액세스 구성 및 사용자 계정 관리 :</strong>\n-> 사용자 초대 만\n-> 공개 액세스\n-> 관리자 인증 액세스</li>\n<li><strong>원하는 플랫폼을 통해 알림을 통해 활성 사용자의 참여 유도 :</strong>\n-> 푸시 알림\n-> 이메일 및 이메일 요약\n-> SMS</li>\n<li><strong>필요에 따라 맞춤 채팅 그룹 만들기 :</strong>\n-> 모든 사용자가\n그룹을 만들 수 있음 -> 관리자 만 그룹을 만들 수 있음\n-> 사용자가 그룹에 가입하고\n볼 수 있음 -> 사용자는 관련 서클에없는 그룹을 볼 수 없음</li>\n</ol>\n<h2 id=\"contus-fly-는-채팅-앱-솔루션의-수익-창출을-통해-귀하의-머니를-만드는데-다양한-기능을-제공합니다\" style=\"position:relative;\"><a href=\"#contus-fly-%EB%8A%94-%EC%B1%84%ED%8C%85-%EC%95%B1-%EC%86%94%EB%A3%A8%EC%85%98%EC%9D%98-%EC%88%98%EC%9D%B5-%EC%B0%BD%EC%B6%9C%EC%9D%84-%ED%86%B5%ED%95%B4-%EA%B7%80%ED%95%98%EC%9D%98-%EB%A8%B8%EB%8B%88%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EB%8B%A4%EC%96%91%ED%95%9C-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"contus fly 는 채팅 앱 솔루션의 수익 창출을 통해 귀하의 머니를 만드는데 다양한 기능을 제공합니다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contus Fly 는 채팅 앱 솔루션의 수익 창출을 통해 귀하의 머니를 만드는데 다양한 기능을 제공합니다.</h2>\n<p><img src=\"https://cdn-images-1.medium.com/freeze/max/30/1*gqjHqYySlGsuL9gs7P54Zg.png?q=20\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*gqjHqYySlGsuL9gs7P54Zg.png\" alt=\"\"></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*gqjHqYySlGsuL9gs7P54Zg.png\" alt=\"\"></p>\n<p>1. 완전히 무료\n2. 인앱 결제\n3. 모바일 광고\n4. 스폰서\n5. 구독</p>\n<blockquote>\n<p><strong>\"모든 새로운 친구 (채팅 앱)는 미래에도 여전히 여유가 있습니다.\"</strong></p>\n</blockquote>\n<p>당신이하려고하면 <a href=\"http://www.contus.com/messaging-solutions.php?utm_source=whatsapp-clone&#x26;utm_medium=CTA&#x26;utm_campaign=Hackernoon\"><strong>채팅 응용 프로그램을 구축</strong></a> WhatsApp 에 같이 추가 현대적인 기능 향상, 당신은 동적 기능을 사용하여 채팅 응용 프로그램을 가지고 옳은 길이다.</p>"},{"frontmatter":{"tags":["고성능 아키텍쳐"],"title":"대용량 처리를 위한 서비스 구성"},"internal":{"content":"\n# 대용량 처리를 위한 서비스 구성\n\n# 대용량 처리를 위한 서비스 구성\n\n14 Feb 2017 | [architecture](https://jistol.github.io/blog/tags/#architecture)\n\n![일반적인 서비스의 기본구성](https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/1.png)\n\n일반적인 서비스 구성이 위와 같은 상황에서 Client가 늘어날 경우 웹 서버나 DB서버에서 병목현상이 발생할 수 있으며 병목지점별로 해결 방안이 필요합니다.\n\n## Web서버 확장\n\nWeb서버가 stateless한 구조일 경우 아래와 같이 다수의 Web서버를 두어 부하를 분산 시킬 수 있습니다.\n\n![병목현상해결을 위한 웹 서버의 확장](https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/2.png)\n\n> stateful : 서버쪽에 client와 server의 연속된 동작 상태정보를 저장하는 형태\n> stateless : 서버쪽에 client와 server의 연속된 동작 상태정보를 저장하는 않는 형태\n\n## DB 확장\n\n![일반적인 서비스의 DB구성](https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/3.png)\n\nDB구성이 위와 같을 경우 성능향상을 위해 “Scale Up”과 “Scale Out”을 고려해 볼 수 있습니다.\n\n> scale up : 장비의 성능을 높여 성능향상\n> scale out : 장비의 개수를 늘려 성능향상\n\n## DB Read/Write 분리,분산\n\n대부분의 서비스는 Read가 Write보다 대략 7:3, 8:2비율로 더 많은데 이럴때 Read/Write DB를 분리하면 DB서버의 부하를 줄일 수 있습니다.\n\n![Read/Write DB 분리](https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/4.png)\n\n일반적으로 Master DB를 Write, Replication되는 Slave DB를 Read로 사용하는데 기본적으로 4대로 구성합니다.\n\n> Master : Write\n> Slave 1,2,3 : Read\n> 1번서버 장애시 2번서버는 서비스를 하며 3번 서버는 서비스를 중단하고 1번서버 복구를 위한 DB복사를 진행해야합니다.\n> 서비스중인 DB에서 복사시 부하가 가중되므로 여분의 DB가 필요합니다.\n\n- ## Eventual Consistency\n\n  Master의 내용을 Slave로 Replication하는 과정은 동기/비동기 방식이 있는데 비동기식일 경우 데이터 불일치가 발생할 수 있습니다.\n  불일치하더라도 시간이 지나면 데이터가 같아지는데 이를 **“Eventual Consistency”**라고 합니다.\n  데이터 일관성이 중요한 경우 Read를 분리할때 위와 같은 문제점을 인지해야합니다.\n\nRead/Write DB 분기방식으로는 아래와 같은 방법이 있습니다.\n\n- DBProxy 서버를 이용\n  - 프록시 서버가 쿼리를 분석하여 select시는 Read서버, 그 외엔 Master서버로 분기해줍니다.\n  - MySql Proxy, MaxScale …\n- MySql Replication Jdbc Driver 사용\n  - Jdbc Driver상에서 내부적으로 readonly 옵션에 따라 Master/Slave장비를 선택해줍니다.\n  - “[MySQL에서ReplicationDriver사용시장애취약점리포트\\-기능테스트](http://gywn.net/2012/07/mysql-replication-driver-error-report/#MySQL에서ReplicationDriver사용시장애취약점리포트-기능테스트)” 포스팅을 보시면 취약점에 대한 테스트 결과및 Oracle측의 답변이 있습니다.(2012년도 포스팅이니 현재는 해결이 됬는지 모르겠습니다.)\n  - “[권남 \\- MySQL JDBC](http://kwonnam.pe.kr/wiki/database/mysql/jdbc#replication_jdbc_driver)“에도 역시 여러가지 문제점들이 도출되어 있습니다.\n  - 결론적으로 사용 안하는 쪽이 나을듯 합니다.\n- Spring LazyConnectionDataSourceProxy + AbstractRoutingDataSource 사용\n  - Spring에서 Transaction readonly 옵션을 사용하여 분기하는 방법입니다.\n  - AbstractRoutingDataSource : 여러개의 DateSource를 하나로 묶고 자동 분기처리\n  - LazyConnectionDataSourceProxy : 트랜잭션 시작되더라도 실제 커넥션이 필요한 경우에 데이터소스에서 커넥션을 반환\n\n## Write증가시 파티셔닝\n\nwrite가 증가하게 되면 Master로부터 Replication을 받기 위해 Slave의 write IO가 증가하게 됩니다.\n그렇게 되면 Read Slave를 아무리 늘려도 성능개선이 미미해지는데 이럴때는 Write를 줄이는 파티셔닝을 해야합니다.\n\n![Read/Write DB 분리](https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/5.png)\n\n- ## 파티셔닝(Partitioninig)\n\n  - 성능,가용성,정비용이성을 목적으로 논리적 데이터 요소들을 다수의 테이블로 쪼개는 행위\n  - 수직분할(Vertical Partitioninig)\n    - 테이블의 Column 단위로 파티셔닝하는 방법\n    - 스키마가 서로 달라집니다.\n  - 수평분할(Sharding : Horizontal Partitionning)\n    - 테이블의 Row 단위로 파티셔닝하는 방법\n    - 스키마는 동일합니다.\n\n- ## 파티션 방법\n\n  - 수동 파티셔닝 : 분석된 테이블 정보를 이용하여 파티션 뷰를 직접 생성\n  - 파티션 테이블 :\n    - Range 파티셔닝\n      - 특정 기간 별로 파티션을 나눔\n      - 주로 날짜조건 사용\n    - Hash 파티셔닝\n      - Hash함수에 적용한 결과값이 같은 레코드별로 나눔\n      - 변별력 좋고 데이터분포가 고른 컬럼을 선정해야 효과적\n    - List 파티셔닝\n      - 사용자에 의해 미리 정해진 그룹핑 기준에 따라 분할\n    - 결합 파티셔닝\n      - 위 파티션 기법을 조합하여 사용\n  - 자세한 설정방법은 [구루비 DB 스터디 \\- 1. 테이블 파티셔닝](http://wiki.gurubee.net/pages/viewpage.action?pageId=26742648)을 참조\n\n## 참고\n\n[대용량 서버구축을 위한 Memcached와 Redis](http://www.hanbit.co.kr/store/books/look.php?p_code=E1904063627)\n[Java 에서 DataBase Replication Master/Slave (write/read) 분기 처리하기](http://kwon37xi.egloos.com/5364167)\n[MySQL에서 Replication Driver 사용 시 장애 취약점 리포트](http://gywn.net/2012/07/mysql-replication-driver-error-report/)\n[권남 \\- MySQL JDBC](http://kwonnam.pe.kr/wiki/database/mysql/jdbc)\n[H2DB \\- LazyConnectionDataSourceProxy 예제](http://www.programcreek.com/java-api-examples/index.php?source_dir=replication-datasource-master/src/test/java/kr/pe/kwonnam/replicationdatasource/config/WithRoutingDataSourceConfig.java)\n[구루비 DB 스터디 \\- 1. 테이블 파티셔닝](http://wiki.gurubee.net/pages/viewpage.action?pageId=26742648)\n[오라클 성능 고도화 원리와 해법 2 \\[11\\-1B\\]](http://bysql.net/index.php?document_srl=15154&mid=w201101B)\n"},"html":"<h1 id=\"대용량-처리를-위한-서비스-구성\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%84%B1\" aria-label=\"대용량 처리를 위한 서비스 구성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대용량 처리를 위한 서비스 구성</h1>\n<h1 id=\"대용량-처리를-위한-서비스-구성-1\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%84%B1-1\" aria-label=\"대용량 처리를 위한 서비스 구성 1 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대용량 처리를 위한 서비스 구성</h1>\n<p>14 Feb 2017 | <a href=\"https://jistol.github.io/blog/tags/#architecture\">architecture</a></p>\n<p><img src=\"https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/1.png\" alt=\"일반적인 서비스의 기본구성\"></p>\n<p>일반적인 서비스 구성이 위와 같은 상황에서 Client가 늘어날 경우 웹 서버나 DB서버에서 병목현상이 발생할 수 있으며 병목지점별로 해결 방안이 필요합니다.</p>\n<h2 id=\"web서버-확장\" style=\"position:relative;\"><a href=\"#web%EC%84%9C%EB%B2%84-%ED%99%95%EC%9E%A5\" aria-label=\"web서버 확장 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web서버 확장</h2>\n<p>Web서버가 stateless한 구조일 경우 아래와 같이 다수의 Web서버를 두어 부하를 분산 시킬 수 있습니다.</p>\n<p><img src=\"https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/2.png\" alt=\"병목현상해결을 위한 웹 서버의 확장\"></p>\n<blockquote>\n<p>stateful : 서버쪽에 client와 server의 연속된 동작 상태정보를 저장하는 형태\nstateless : 서버쪽에 client와 server의 연속된 동작 상태정보를 저장하는 않는 형태</p>\n</blockquote>\n<h2 id=\"db-확장\" style=\"position:relative;\"><a href=\"#db-%ED%99%95%EC%9E%A5\" aria-label=\"db 확장 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 확장</h2>\n<p><img src=\"https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/3.png\" alt=\"일반적인 서비스의 DB구성\"></p>\n<p>DB구성이 위와 같을 경우 성능향상을 위해 “Scale Up”과 “Scale Out”을 고려해 볼 수 있습니다.</p>\n<blockquote>\n<p>scale up : 장비의 성능을 높여 성능향상\nscale out : 장비의 개수를 늘려 성능향상</p>\n</blockquote>\n<h2 id=\"db-readwrite-분리분산\" style=\"position:relative;\"><a href=\"#db-readwrite-%EB%B6%84%EB%A6%AC%EB%B6%84%EC%82%B0\" aria-label=\"db readwrite 분리분산 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB Read/Write 분리,분산</h2>\n<p>대부분의 서비스는 Read가 Write보다 대략 7:3, 8:2비율로 더 많은데 이럴때 Read/Write DB를 분리하면 DB서버의 부하를 줄일 수 있습니다.</p>\n<p><img src=\"https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/4.png\" alt=\"Read/Write DB 분리\"></p>\n<p>일반적으로 Master DB를 Write, Replication되는 Slave DB를 Read로 사용하는데 기본적으로 4대로 구성합니다.</p>\n<blockquote>\n<p>Master : Write\nSlave 1,2,3 : Read\n1번서버 장애시 2번서버는 서비스를 하며 3번 서버는 서비스를 중단하고 1번서버 복구를 위한 DB복사를 진행해야합니다.\n서비스중인 DB에서 복사시 부하가 가중되므로 여분의 DB가 필요합니다.</p>\n</blockquote>\n<ul>\n<li>\n<h2 id=\"eventual-consistency\" style=\"position:relative;\"><a href=\"#eventual-consistency\" aria-label=\"eventual consistency permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Eventual Consistency</h2>\n<p>Master의 내용을 Slave로 Replication하는 과정은 동기/비동기 방식이 있는데 비동기식일 경우 데이터 불일치가 발생할 수 있습니다.\n불일치하더라도 시간이 지나면 데이터가 같아지는데 이를 **“Eventual Consistency”**라고 합니다.\n데이터 일관성이 중요한 경우 Read를 분리할때 위와 같은 문제점을 인지해야합니다.</p>\n</li>\n</ul>\n<p>Read/Write DB 분기방식으로는 아래와 같은 방법이 있습니다.</p>\n<ul>\n<li>DBProxy 서버를 이용\n<ul>\n<li>프록시 서버가 쿼리를 분석하여 select시는 Read서버, 그 외엔 Master서버로 분기해줍니다.</li>\n<li>MySql Proxy, MaxScale …</li>\n</ul>\n</li>\n<li>MySql Replication Jdbc Driver 사용\n<ul>\n<li>Jdbc Driver상에서 내부적으로 readonly 옵션에 따라 Master/Slave장비를 선택해줍니다.</li>\n<li>“<a href=\"http://gywn.net/2012/07/mysql-replication-driver-error-report/#MySQL%EC%97%90%EC%84%9CReplicationDriver%EC%82%AC%EC%9A%A9%EC%8B%9C%EC%9E%A5%EC%95%A0%EC%B7%A8%EC%95%BD%EC%A0%90%EB%A6%AC%ED%8F%AC%ED%8A%B8-%EA%B8%B0%EB%8A%A5%ED%85%8C%EC%8A%A4%ED%8A%B8\">MySQL에서ReplicationDriver사용시장애취약점리포트-기능테스트</a>” 포스팅을 보시면 취약점에 대한 테스트 결과및 Oracle측의 답변이 있습니다.(2012년도 포스팅이니 현재는 해결이 됬는지 모르겠습니다.)</li>\n<li>“<a href=\"http://kwonnam.pe.kr/wiki/database/mysql/jdbc#replication_jdbc_driver\">권남 - MySQL JDBC</a>“에도 역시 여러가지 문제점들이 도출되어 있습니다.</li>\n<li>결론적으로 사용 안하는 쪽이 나을듯 합니다.</li>\n</ul>\n</li>\n<li>Spring LazyConnectionDataSourceProxy + AbstractRoutingDataSource 사용\n<ul>\n<li>Spring에서 Transaction readonly 옵션을 사용하여 분기하는 방법입니다.</li>\n<li>AbstractRoutingDataSource : 여러개의 DateSource를 하나로 묶고 자동 분기처리</li>\n<li>LazyConnectionDataSourceProxy : 트랜잭션 시작되더라도 실제 커넥션이 필요한 경우에 데이터소스에서 커넥션을 반환</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"write증가시-파티셔닝\" style=\"position:relative;\"><a href=\"#write%EC%A6%9D%EA%B0%80%EC%8B%9C-%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D\" aria-label=\"write증가시 파티셔닝 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Write증가시 파티셔닝</h2>\n<p>write가 증가하게 되면 Master로부터 Replication을 받기 위해 Slave의 write IO가 증가하게 됩니다.\n그렇게 되면 Read Slave를 아무리 늘려도 성능개선이 미미해지는데 이럴때는 Write를 줄이는 파티셔닝을 해야합니다.</p>\n<p><img src=\"https://jistol.github.io/assets/img/architecture/architecture-traffic-issue/5.png\" alt=\"Read/Write DB 분리\"></p>\n<ul>\n<li>\n<h2 id=\"파티셔닝partitioninig\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9Dpartitioninig\" aria-label=\"파티셔닝partitioninig permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝(Partitioninig)</h2>\n<ul>\n<li>성능,가용성,정비용이성을 목적으로 논리적 데이터 요소들을 다수의 테이블로 쪼개는 행위</li>\n<li>수직분할(Vertical Partitioninig)\n<ul>\n<li>테이블의 Column 단위로 파티셔닝하는 방법</li>\n<li>스키마가 서로 달라집니다.</li>\n</ul>\n</li>\n<li>수평분할(Sharding : Horizontal Partitionning)\n<ul>\n<li>테이블의 Row 단위로 파티셔닝하는 방법</li>\n<li>스키마는 동일합니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<h2 id=\"파티션-방법\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%98-%EB%B0%A9%EB%B2%95\" aria-label=\"파티션 방법 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티션 방법</h2>\n<ul>\n<li>수동 파티셔닝 : 분석된 테이블 정보를 이용하여 파티션 뷰를 직접 생성</li>\n<li>파티션 테이블 :\n<ul>\n<li>Range 파티셔닝\n<ul>\n<li>특정 기간 별로 파티션을 나눔</li>\n<li>주로 날짜조건 사용</li>\n</ul>\n</li>\n<li>Hash 파티셔닝\n<ul>\n<li>Hash함수에 적용한 결과값이 같은 레코드별로 나눔</li>\n<li>변별력 좋고 데이터분포가 고른 컬럼을 선정해야 효과적</li>\n</ul>\n</li>\n<li>List 파티셔닝\n<ul>\n<li>사용자에 의해 미리 정해진 그룹핑 기준에 따라 분할</li>\n</ul>\n</li>\n<li>결합 파티셔닝\n<ul>\n<li>위 파티션 기법을 조합하여 사용</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>자세한 설정방법은 <a href=\"http://wiki.gurubee.net/pages/viewpage.action?pageId=26742648\">구루비 DB 스터디 - 1. 테이블 파티셔닝</a>을 참조</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<p><a href=\"http://www.hanbit.co.kr/store/books/look.php?p_code=E1904063627\">대용량 서버구축을 위한 Memcached와 Redis</a>\n<a href=\"http://kwon37xi.egloos.com/5364167\">Java 에서 DataBase Replication Master/Slave (write/read) 분기 처리하기</a>\n<a href=\"http://gywn.net/2012/07/mysql-replication-driver-error-report/\">MySQL에서 Replication Driver 사용 시 장애 취약점 리포트</a>\n<a href=\"http://kwonnam.pe.kr/wiki/database/mysql/jdbc\">권남 - MySQL JDBC</a>\n<a href=\"http://www.programcreek.com/java-api-examples/index.php?source_dir=replication-datasource-master/src/test/java/kr/pe/kwonnam/replicationdatasource/config/WithRoutingDataSourceConfig.java\">H2DB - LazyConnectionDataSourceProxy 예제</a>\n<a href=\"http://wiki.gurubee.net/pages/viewpage.action?pageId=26742648\">구루비 DB 스터디 - 1. 테이블 파티셔닝</a>\n<a href=\"http://bysql.net/index.php?document_srl=15154&#x26;mid=w201101B\">오라클 성능 고도화 원리와 해법 2 [11-1B]</a></p>"},{"frontmatter":{"tags":["고성능 아키텍쳐"],"title":"성능 엔지니어링에 대한 접근 방법"},"internal":{"content":"\n# 성능 엔지니어링에 대한 접근 방법\n\n성능 개선, Performance Tuning, 용량 선정 과 같은 튜닝 관련 용어들은 모든 개발자나 엔지니어에게 모두 흥미가 가는 주제일 것이다. 그 만큼 소프트웨어에서 고성능을 내는 시스템은 만들기도 힘들뿐더러, 고성능 시스템이란 즉 잘 설계되고 구현된 소프트웨어를 뜻하는 것이니 관심을 가지는 것이 당연하지 않을까 싶다.\n\n필자의 경우, 엔터프라이즈 시스템에 대한 약 6년간 장애 해결 , 장애 회피 설계, 성능 개선, 고성능 시스템 설계 및 구현에 관련된 일을 해왔다. 특히 장애 해결과 성능 개선 작업은 하고 나면 뿌듯하기는 하지만, 특정한 기술이 필요하기 보다는 문제를 정의하고 접근하는 능력과 끝까지 목표를 달성할 때까지 지루한 작업을 반복적으로 할 수 있는 인내심을 필요로 하는 작업이다\n\n이번 챕터에서는 Performance Engineering의 전반적인 접근 방법과, 용량 산정 방법 그리고 자바 기반의 서버 애플리케이션에 대한 성능 튜닝 및 병목 발견 방법에 대해서 설명하고자 한다.\n\n# Performance Engineering 의 정의와 범위\n\nPerformance Engineering은 시스템의 목표 성능 (응답 시간과 동시 접속자수) 을 정의 하고, 이를 달성하기 위해서, 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.\n\n좁게 생각하면, 코드상의 병목을 잡고, 시스템의 설정 (Configuration)을 바꿔서 성능을 올리는 튜닝으로 생각할 수 있지만, 성능 목표의 정의에서 부터, 최적의 성능을 내기 위한 디자인 및 구현과 같은 개발 초기의 설계 부분와 개발후의 운영단계에서 모니터링 까지 전과정을 포함한다.\n\n## Performance Engineering은 언제 해야 하는가?\n\nPerformance Engineering은 전체 소프트웨어 개발 과정에 걸쳐서 크게 아래와 같이 4단계에 걸쳐서 일어난다.\n\n![](https://t1.daumcdn.net/cfile/tistory/234FEE405226094801)\n\n위의 개발 모델은 전형적인 Water fall model이다. 개발프로세스 챕터에서도 설명하였지만 , 스크럼과 같은 애자일 방법론을 사용하더라도 큰 범위에서 개발 사이클은 Waterfall 모델과 크게 다르지 않게 된다. (각 단계별을 SPRINT 단위로 수행한다.)\n\n① 분석 단계\n\n초기 요구 사항 분석 및 시스템 기획 단계에서는 성능에 대한 목표를 정해야 한다.\n\n목표 응답시간은 어떻게 되는지, 시스템을 사용할 총 사용자수와 동시에 시스템을 사용하는 동시접속자 수가 어떻게 되는지와 같은 성능 목표를 정의한다.\n\n또한 고려해야 하는 사항중의 하나는 성능 모델이다. 시스템에 부하가 어떤 패턴으로 들어오는지를 정의할 필요가 있다.\n\n예를 들어 일반적인 웹컨텐츠 사이트의 경우 사용자가 들어와서 페이지 컨텐츠를 1~3분 내에 읽고 다른 페이지로 이동하다가, 20 여분 후에는 로그아웃하거나 다른 사이트로 이동한다. 즉 한 사용자의 체류 시간은 20분정도되며, 총 평균 20 페이지를 보는 트렌젝션을 발생 시키고 나간다고 할 수 있다. 한글로 만든 사이트이고, 육아나 주부를 대상으로 한 사이트라고 가정하면, 시스템의 부하는 한국 시간으로 아이들이 학교나 유치원을 간후인 10시~11시와, 저녁시간대인 10시~12시 사이에 몰린다고 가정할 수 있다.\n\n다른 예로 게임 시스템을 예로 들어보자, 주로 초등학생을 타켓으로 한 게임이라면, 방과후 시간인 3 시~5시 대에 부하가 가장 몰릴 것이며, 게임의 종류에 따라 다르겠지만, 스타크래프트와 같은 게임의 경우 한번 플레이에 40분 정도 소요가 되고, 한 사용자가 하루에 두번정도 게임을 한다 가정 아래, 사용자당 체류 시간은 2시간, 게임 횟수는 2회/일. 그리고 주요 부하는 3~5시 오후대 라는 성능 모델을 만들 수 있다.\n\n초기 성능 정의는 서비스의 종류(웹,게임, 기업 시스템,쇼핑,뱅킹등) 나, 서비스를 사용하는 사용자층, 그리고 서비스를 사용하는 지역. 즉 전세계를 서비스하는 시스템이라면 시스템의 부하는 365일 ,24시간 거의 다 걸린다고 봐야 한다. 그러나 한국만을 대상으로 서비스 하는 한국어로 된 사이트인 경우, 새벽 시간에는 일반적으로 로드가 없는 것과 같은 한국의 시간대에 영향을 받을 뿐만 아리나 명절,휴일,휴가와 같은 한국이라는 국가 특성에 따라 시스템의 부하가 영향을 받는다.\n\n② 디자인 단계\n\n다음으로는 디자인 단계에서는 목표 성능과 용량을 달성할 수 있는 규모의 시스템으로 설계를 진행한다.\n\n성능 관점에서 시스템 디자인은 항상 Peak Time (최대 성능)에 맞춰서 디자인이 된다. 최대 성능을 기반으로 전체 시스템이 받아낼 수 있는 용량과 응답 시간을 고려해야 한다.\n\n특히 성능과 용량은 애플리케이션 디자인 뿐만 아니라 Technology selection에도 많은 영향을 받는다. 어떤 하드웨어를 사용할 것인지, 어떤 미들웨어나 프레임웍을 사용할 것인지이에 따라 용량과 성능의 차이가 많이 발생하기 때문에, 디자인 단계에서 부터 성능과 용량을 감안해서 시스템을 설계해야 한다.\n\n**하드웨어 관점**에서는 예전에는 성능 모델을 산정한 후에, Peak Time 기준 ( 최대 성능 요구)으로 시스템을 설계하고, 하드웨어를 구매 하였으나, 근래에는 클라우드를 이용하여 필요시에만 하드웨어를 탄력적으로 사용하는 Auto Scale Out 모델을 많이 사용한다.\n\n기업 내부의 업무 처럼 (예를 들어 이메일), 부하가 일정하고 예측이 가능한 경우에는 Fixed 된 사이즈의 하드웨어를 사용하도록 설계 하고, 출시 이벤트 행사 사이트와 같이 부하가 갑자기 몰리는 시스템의 경우 클라우드를 고려해보는 것도 권장할만 하다.\n\n또한 빠른 응답 시간이 필요할 경우 SSD 디스크를 사용하거나, RAID 구성도 5 보다는 1+0 등을 고려하는 등, 성능 모델에 따라서 적절한 하드웨어 선정과 구성 설계가 필요하다.\n\n**미들웨어**나 프레임웍 관점에서도 정의된 성능 모델에 따라 적절한 제품군과 설계 구조를 채택해야 한다 . 100,000 사용자 정도의 시스템 규모에서는 RDBMS 를 사용해도 성능이나 용량상에 문제가 없다. 그러나 50,000,000 사용자 정도를 지원해야 하는 시스템의 경우 그냥 RDBMS 를 사용할 수 없다. Sharding이나, NoSQL 과 같은 다른 차원의 접근이 필요하다.\n\n또한 빠른 응답 시간을 요구하는 경우 Redis나 Memcached와 같은 Cache 솔루션을 적극적으로 활용하거나, 미들웨어 부분에서는 Tomcat과 같은 일반적은 Web Application Server 보다는 Netty나 Vertex와 같은 고성능 미들웨어를 고려해볼 수 있다.\n\n이러한 성능이나 용량에 관련된 제품 선정이나 설계는 돌려 보지 않으면 사실 확신을 가지기 어렵다. 그래서 가능하면, Technology selection 후에 , 간단한 프로토타입을 구현한후에 시나리오가 단순한 대규모의 성능 및 용량 테스트를 해보는 PoC (Proof Of Concept)과 같은 작업을 이 단계에서 수행하는 것을 권장한다.\n\n③ 개발단계\n\n개발 단계는 개발프로세스 챕터에서 설명하였듯이, risk 가 높은 부분과 아키텍쳐에 관련되는 부분, 난이도가 높은 부분 , 핵심 기능등을 개발 초기의 스프린트에서 개발한다.\n\n초기 스프린트가 끝나고 릴리즈가 되서 성능 테스트가 가능한 QA나 스테이징 환경으로 시스템이 이전되면, Performance Engineering 역량을 이 단계에 집중하여 , 시스템의 아키텍쳐와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 수행한다.\n\n초기 단계에 성능 목표의 달성 가능 여부가 판단되어야, 아키텍쳐 변경이 가능하고, 주요 성능 이슈들을 초반에 발견해야 , 발견된 성능 문제들에 대해서는 같은 문제가 발생하지 않도록 디자인 가이드나 코딩 가이드를 개발자들에게 배포하여 성능에 대한 위험도를 줄일 수 있다.\n\n④ 최종 테스트 단계\n\n앞의 단계에서 성능과 용량을 고려해서 설계가 되었고, 개발 초기 단계에서 성능과 용량 부분을 검증을 제대로 하였다면, 최종 테스트 단계에서는 개발된 최종 시스템에 대한 성능과 용량 부분의 측정과 미세 튜닝 (애플리케이션의 병목을 찾아서 부분적으로 수정하거나 , 하드웨어나 미들웨어의 Configuration 하는 수준)을 하는 정도로 마무리가 되어야 한다.\n\n이 과정에서는 실수로 잘못한 설정(configuration) 이나 잘못된 코딩으로 된 부분에 대해서 검증이 이뤄지는데, 이 경우에는 보통 2배에서 크게는 10 배까지의 성능 향상이 이루어진다. 이런 경우는 대부분 실수에 의한 것이고 성능이 터무니 없이 낮게 나오기 때문에 찾기가 쉽다.\n\n예를 들어 로그 파일을 NFS와 같은 리모트 디스크에 쓴다던지, Intel 계열의 CPU에서 하이퍼쓰레딩을 ON을 안했다던지와 같이 실수에 의한 경우가 많다.\n\n이런 오류성의 문제들이 해결되면 실제 미세 튜닝에 들어가게 되는데, JVM 튜닝이나 톰캣의 설정 튜닝, SQL 튜닝들이 이루어지는데 , 이 미세 튜닝을 통해서는 비약적인 성능향상은 이루어나지 않는다. 보통 20% 내외 정도 성능이 올라간다고 보면 된다.\n\n⑤ 운영 단계\n\n마지막으로 시스템이 운영 단계로 넘어가게 되면, 테스트시에 발견되지 않은 성능적인 문제가 있을 수 있기 때문에, 모니터링 도구를 사용하여 지속적으로 성능을 모니터링 하고 , 성능상에 문제가 있는 부분을 지속적으로 수정해야 한다. 웹서버의 access로그에서 응답 시간을 모니터링 하거나, 제니퍼([http://www.jennifersoft.com](http://www.jennifersoft.com/) ) 과 같은 전문적인 APM (Application Performance Monitoring)툴이나, Ganglia와 같은 시스템 모니터링 도구를 사용하면, 시스템의 성능 상태를 잘 알 수 있다.\n\n더불어 용량 부분에 대해서도 운영단에서는 고민을 해야 하는데, 일반적으로 PEAK Time의 시스템 용량이 (CPU) 80% 정도에 다다르면, 시스템 용량 증설을 고려해야 한다.\n\n그리고 업무에 특성에 맞게 미리미리 용량을 준비해놓는게 좋다. 예를 들어 대학의 수강 신청 시스템의 경우, 학기 시작하는 날에 부하가 폭주하기 때문에, 클라우드 기반일 경우 수강신청 전에 시스템 수를 미리 늘려놓는다던지, 클라우드가 아닌 경우, 수강 신청 기간을 앞뒤로 서버를 임대해서 용량을 늘려놓는 등의 대책을 미리 세워놓을 수 있다.\n\n마지막으로, 운영 단계에서 Performance Engineering 관점으로 챙겨야 하는 부분은 운영 로그의 수집이다. 성능 및 용량 목표 설정은 매우 중요한 과정이다. 특히 용량 목표의 경우에는 기존의 업무 시스템의 사용 패턴을 분석 하는 것이 가장 효율적이기 때문에 운영 시스템의 로그를 수집하고 분석하여 운영 중인 업무 시스템의 성능 모델을 분석 및 보유 해놓는 것이 좋다.\n\n## 시스템 용량 산정 (Capacity Planning)\n\n더 자세한 설명에 들어가기 앞서서, 성능에 관련된 용어와 함께 시스템의 목표 용량 산정 방법에 대해서 이야기 해보도록 하자.이 용어는 이 글에서 정의하는 의미의 용어이며, 다른 성능 이론에서 언급되는 용어와 다소 다를 수 있다.\n\nl **Response Time (응답 시간) :** 사용자가 서버에 요청을 한 시간에서 부터 , 응답을 받을 때 까지의 모든 시간을 포함한다. 이 응답시간은 내부적으로 다음과 같이 조금 더 세분하게 분리된다.\n\n![](https://t1.daumcdn.net/cfile/tistory/27427E435226095A1B)\n\nNetwork Time (또는 Latency time). 서버에 요청을 했을때, Request를 보내고 받을 때 소요되는 네트워크 시간을 의미한다.\n\nTransaction Time : 서버에서 실제 트렉젝션이 처리되는 시간을 의미 한다.\n\nThink Time : 사용자가 요청에 대해서 응답을 받은 후에, 웹페이지를 보거나 화면을 보는 등의 작업을 하는 시간의 의미한다.\n\n예를 들어 보면 한국의 사용자가 미국이 페이스북을 사용한다고 했을때, 사용자가 웹 브라우져에서 클릭을 하면, 요청이 서버로 도달할때 까지 걸리는 시간 Network time (Request), 서버가 요청을 받아서 처리를 하고, 응답을 하는 시간 (Transaction Time), 그리고 그 응답이 사용자의 브라우져 까지 도착하는 시간이 Network time (Response) 이다. 이 전체 시간을 합친 것이 Response Time 이 된다.\n\n응답을 받은 후에는 사용자가 페이스북 내용을 보는데 소요 되는 시간이 Think Time이 된다.\n\nThink Time 까지 포함하여 다음 요청이 발생하기 까지의 전체 시간을 Request Interval 이라고 한다.\n\nl **Concurrent User (동시 사용자) :** 시스템을 현재 사용하고 있는 사용자를 정의한다. 웹사이트를 사용하기 위해서, 현재 브라우져를 열어놓고 웹사이트를 보고 있는 것과 같이 현재 시스템을 사용하고 있는 사용자 수를 의미 한다.\n\n![](https://t1.daumcdn.net/cfile/tistory/232F2044522609672F)\n\n위의 그림을 보자, 5명의 사용자 A~E가 있다고 가정했을 때, 단위 시간 10분동안에 Transaction Time 과 Think Time중에 있는 사용자는 A,B,C 총 3명으로 해다 시간 10 분간의 Concurrent User는 3명이 된다.\n\nl Active User (액티브 사용자) : 현재 시스템에 트렌젝션을 실행하여 부하를 주고 있는 사용자를 정의한다.\n\n기존에는 Concurrent User와 Active User간의 차이가 없었다. 이 개념은 웹이 생기면서 구체화된 개념인데, 웹 사이트를 사용하기 위해서 컴퓨터 앞에 앉아 있는다고 하더라도, 웹 페이지가 로딩 되는 순간에만 서버는 부하를 받고, 페이지가 웹 브라우져로딩 된 후에는 부하를 받지 않고 사용자는 로딩된 페이지를 보는데 시간이 발생한다. 이 시간동안에는 서버는 부하를 받지 않는다. 즉 시스템을 사용하기 위해서 웹 사이트를 열어 놓고 있는다 하더라도 지속적으로 서버에 부하를 주는 것이 아니기 때문에 Concurrent User와 Active User 의 개념 차이가 발생한다.\n\nActive User는 클릭을 발생시켜서 그 시간 당시에 서버에 트렌젝션을 발생 시키는 사용자를 의미한다.\n\nActive User의 수는 서버에서 순간 실행되고 있는 Thread 수 ( 쓰레딩 기반의 자바 서버의 경우) 나 Process의 수와 같다. 이 Active User의 수는 실제로 서버가 동시에 처리할 수 있는 트렌젝션의 양을 판단할 수 있는 기준이 되기 때문에 매우 중요한 성능 Factor가 된다.\n\n![](https://t1.daumcdn.net/cfile/tistory/24653E3F5226097221)\n\n위의 그림을 보자, 위의 그림에서 특정 순간에 있는 사용자는 총 5 명으로 Concurrent User 는 5명이지만, Transaction Time 구간중의 있는 사용자는 A,B,C 로, 총 Active User는 3 명이 된다 .\n\nl Transaction (트렌젝션) : Transaction이란, 사용자로 부터의 요청을 다루는 단위를 정의 한다. 이 정의가 상당히 중요한데, 성능 모델링이나 성능 테스트 시 이 Transaction의 정의에 따라서 시스템의 성능이 매우 다르게 정의 된다.\n\n예를 들어서 사용자가 웹 페이지를 클릭했을때, 그 페이지에 대한 응답을 받는 것 까지를 하나의 트렌젝션이라고 정의 하자.\n\n이 때, 웹페이지에는 서버에서 생생된 HTML 이외에, 여기서 참고 하는 리소스 즉, 이미지나 동영상, 자바 스크립트들이 들어있을 수 있다. 이 경우 트렌젝션에 대한 응답 시간을 측정할때, HTML 생성 이외에 이러한 리소스들을 로딩 하는 것 까지 하나의 트렌젝션으로 정의 해야 하느냐를 고려해야 한다.리소스에 로딩을 트렌젝션의 범위로 넣게 되면 전체 시스템의 응답 시간은 떨어지게 된다. (리소스를 로딩할 때 까지 기다려야 하니).\n\n이러한 트렌젝션의 정의는 무엇을 판단 기준으로 할것인가에 따라 결정이 되는데, 예를 들어 리소스를 톰캣과 같은 WAS에서 처리하지 않고 앞단의 CDN이나 웹서버에서 처리할 경우 톰캣은 리소스에 대한 트렌젝션 요청을 받지 않기 때문에, 전체 시스템에서 비지니스 로직에 대한 처리 성능을 측정하고자 할 때는 리소스에 대한 로딩 시간을 계산하지 않고 트렌젝션을 정의 한다. 또한 리소스에 대한 로딩은 비지니스 로직에 대한 처리에 비해서 부하가 상대적으로 매우 적고, 일반적으로 브라우져에 캐쉬되기 때문에 보통 서버의 성능 측정시 이러한 리소스 로딩에 대한 부하는 트렌젝션의 단위로 처리하지 않는 경우가 많다.\n\nl TPS(Transaction Per Second) : 초당 처리할 수 있는 트렌젝션의 양을 정의 한다. 주로 서버의 성능 평가 기준이 된다.\n\nActive 사용자가 순간 Transaction을 처리한다고 하면, 이를 목표 응답시간 (Response Time)으로 나눈 값이 목표 TPS가 된다. 예를 들어, Active User가 50 명이고, 개당 Response Time이 2초 라고 하면, 이 시스템의 TPS는 25 TPS가 된다.\n※ Network time이 미세하다고 판단하여, Network time을 0으로 가정하여 계산\n\nl HPS(Hit Per Second) : 시스템이 처리할 수 있는 모든 웹 request의 초당 처리량이다. TPS가 비지니스 트렌젝션에 대한 처리 시간만을 정의 한다면, HPS는 리소스 (이미지, 자바스크립트)에 대한 request 처리량을 포함하기 때문에, TPS에 비해서 10~20 배 정도 높게 나온다.\n\nl Peak Time(피크 타임) : 서버가 순간적으로 가장 부하를 많이 받는 순간을 정의 한다. 보통 서버의 용량 산정이나 성능 설계는 이 시간의 부하량을 기준으로 한다\n\n일반적인 업무 시스템의 경우, 출근 9시~9 시30분 사이가 가장 부하가 높다. 이 때 Peak (최고 정점)을 찍는 순간의 동시 사용자 수와 기준 응답 시간을 목표로 성능 목표를 정의 하는 것이 일반적이다.\n\n위의 개념을 정리해서 공식화 해보자.\n\n① TPS = (Active User) / (Average Response Time) – F1\n\n② TPS = (Concurrent User) / (Request Interval) – F2\n\n③ Active User = TPS \\* (Average Response Time) – F3\n\n④ Active User = (Concurrent User) \\* (Average Response Time) / (Request Interval) – F4\n\n⑤ Active User = (Concurrent User) \\* (Average Response Time) / \\[ (Average Response Time) + (Average Think Time) \\] – F5\n\n예를 들어 Concurrent User가 300명이고, 목표 응답시간이 3초 이내이며, Think Time이 15초 인 시스템의 경우 , F5 공식에 따라서 Active User는 300\\*3/(3+15) = 50 이 되며 , 시스템의 Thread 또는 적정 Process 양은 50개가 된다. 목표 TPS는 약 16.6 TPS가 된다.\n\n위의 공식은 어디까지나 이론적인 공식이다. Network Latency 값은 가변적이며, Think Time 또한 유동적이다. 그러나 용량 산정에는 어느 정도의 산정 기준이 필요하기 때문에, 이 공식을 사용하면 대략적인 시스템에 대한 요구 용량을 예측할 수 있다.\n\n## Performance Engineering 의 절차\n\n그러면 어떤 절차로 성능과 용량을 측정하고 개선하는 절차에 대해서 알아보도록 하자.\n\n### 성능 목표와 모델의 정의\n\n먼저 주요 업무 패턴이나, 튜닝의 대상이 되는 시나리오에 대한 개별 성능 목표를 정의 한다. 예를 들어 전체 성능 목표가 1,000 동시 사용자에 대해서 응답 시간 1초내의 시스템이 전체 성능 목표라고 가정하고, 전체 성능 목표를 대략 1,000 TPS (Transaction Per Second) 라고 하자. 이것이 바로 성능 목표가 된다.\n\n다음으로 성능 모델을 정의 해야 하는데, 해당 시스템의 주요 사용자 시나리오가 여러개 있을 때, 각 시나리오별의 사용 비중을 정의 해야 한다.\n\n예를 들어 사진을 저장하는 클라우드 서비스 시나리오가 있다고 하면, 이 서비스의 주요 사용자 시나리오는\n\n① 로그인\n\n② 사진 리스트\n\n③ 사진 업로드\n\n④ 사진 보기\n\n⑤ 사진 다운로드\n\n⑥ 로드 아웃\n\n등이 된다. 이 중에서 한 사용자가 실행하는 비율을 따져야 한다. 즉 사용자가 로그인 한후 , 리스트 보기를 10번, 업로드를 2번, 보기를 5번 , 그리고 다운로드를 1번 한후에 로그 아웃 한다고 하자. 그러면 비율은 다음과 같이 된다. (전체 트렌젝션 횟수 1+10+2+5+1+1 = 20회)\n\n성능 모델 :로그인의 비율 5%, 리스트 보기 50%, 업로드 10%, 보기 25%, 로그아웃 5%\n\n이 비율을 기준으로 복합 시나리오 (전체 시나리오를 함께 돌리는) 부하테스트를 수행하였을때 , 1000 TPS가 나와야 하고, 각 개별 시나리오에 대해서 최소한, 로그인의 경우 1000 TPS의 5%인 50 TPS, 리스트 보기는 500 TPS를 상회 해야 한다.\n\n### 부하 생성\n\n성능 모델이 정의 되었으면, 이 모델에 따라서 부하를 생성해야 한다.\n\n부하 생성 도구는 여러가지가 있다. 대표적인 오픈 소스 도구로는\n\n가장 간단하게 쓸 수 있는 도구로는 Apache AB 라는 명령어 기반의 도구가 있으며, 복잡한 스크립트를 지원할 수 있는 도구로는 grinder나 apache JMeter 등이 있으며, NHN에서 grinder를 enhancement해서 만든 (GUI가 지원되는) nGrinder라는 도구가 있다.\n\n근래에는 국내에서는 nGrinder라는 도구가 많이 사용되고 있다.\n\n성능 모델이 단순하고, 테스트 시나리오가 간단할 경우에는 Apache ab 등으로도 가능하지만 , 스크립트가 복잡해지는 경우에는 nGrinder와 같은 도구가 유리 하다.\n\n또한 부하 생성에 사용되는 스크립트는 복잡도가 생각보다 높고, 향후 regression(회귀 ) 테스트에도 재 사용되기 때문에, 반드시 형상 관리 시스템을 통해서 (VCS) 관리 하는 것을 권장한다.\n\n※ 자세한 부하 테스트에 대한 방법은 “4장 테스트의 시스템 테스트 “ 부분을 참고하기 바란다.\n\n|\n\n※ 클라우드 컴퓨팅과 부하 테스트 툴 라이센스 모델에 대해서\n\n예전에는 부하 테스트가 사내에서 사내에 있는 시스템을 대상으로 했었기 때문에 큰 문제가 없었다. 그러나 근래 들어서 클라우드 컴퓨팅을 사용하는 사례가 늘어남에 따라, 서비스 시스템이 회사 밖에 즉, 클라우드에 있는 경우가 많아 졌다.\n\n상용 부하 테스트툴의 경우에는 부하 발생기의 위치와 툴 사용자에 대해서 제약을 두는 경우가 있는데, 툴을 구매했다 하더라도, 부하 테스터의 controller (부하 발생기 제외)는 반드시 사내에 있어야 하며, 사용자 역시 그 회사의 내부 직원으로만 한정하는 경우가 있다.\n\n예를 들어, 내가 부하 테스트 도구를 서울에 있는 회사에서 구매하여, 이 툴을 Amazon 클라우드 미국에 설치하고 부하 테스트를 미국 지사 직원을 통해서 진행하는 것이 불가능 하다.\n\n이 경우 부하 테스트 툴의 Controller는 한국 서울 사무소에 설치하고, 부하 생성기만 Amazon에 설치한후 한국 서울 사무소 직원을 통해서만 사용해야 한다.\n\n간혹 (이럴리는 없어야 하겠지만) 부하 테스트 툴의 판매 회사 영업 사원이 이러한 사실을 제대로 통보하지 않아서, 툴을 잘 쓰다가 갑자기 영업 사원이 변경되거나, 부하 테스트 툴의 이전을 요청 하였을때, 갑자기 벤더로 부터, 추가 라이센스 구매 요청을 받을 수 있으니, 구매 전에 반드시 구매 조건에 사용 시나리오와Controller 위치, 사용 주체 및 테스트 대상 시스테들에 대해서 명시적으로 기재 하고 구매 계약을 추진 하는 것이 좋다.\n\n|\n\n### 테스트 및 모니터링\n\n부하 테스트 준비가 되었으면, 부하 테스트를 진행하고 진행중에 주요 성능 Factor에 대해서 지속적으로 모니터링 및 기록을 하여야 한다. 주로 모니터링해야하는 Factor들은 다음과 같다.\n\n![](https://t1.daumcdn.net/cfile/tistory/2467683E5226098A21)\n\n① 애플리케이션 관점\n\n가장 기본적으로 애플리케이션 즉 시스템의 성능을 측정 해야 한다. 주요 모니터링 Factor는 다음과 같다.\n\nResponse Time : Request 별 응답 시간\n\nTPS (Throughput per second) : 초당 요청(Request) 처리량\n\n이 Factor들이 궁극적으로 성능에 대한 최종 목표 값이 되기 때문에, 가장 중요한 성능 Factor가 되며, 부하 생성 도구를 통해서 손쉽게 측정할 수 있다.\n\n② 미들웨어 관점\n\n미들웨어는 애플리케이션이 동작하기 위한 기본적인 솔루션이다.. Apache와 같은 웹서버나 Tomcat과 같은 Web Application 서버 , RabbitMQ와 같은 Message Queue, MySQL 과 같은 데이타 베이스 등이 이에 해당한다.\n\n각 성능 시나리오별로, 거쳐 가는 모든 미들웨어들을 모니터링해야 하는데, 이를 위해서는 각 솔루션에 대한 개별적인 깊은 이해가 필요하다.\n\n웹서버의 경우 거의 성능 문제가 되는 부분은 없다. 성능 문제가 발생하는 부분은 대부분 Network outbound io (bandwidth)쪽이 되는 경우가 많다 . 웹서버가 설치된 하드웨어의 network out bound bandwidth를 모니터링 하는 것이 유용하다.\n\n대부분의 성능 문제는 실제 애플리케이션 로직이 수행되는 Tomcat과 같은 application server와 데이타 베이스단에서 많이 발생하는데, application server의 경우에는 Thread의 수와 Queue의 길이가 1차 모니터링 대상이 된다.\n\n서버가 용량을 초과 하게 되면, Idle Thread수가 떨어지게 되고, Idle Thread가 0이 되면 request message가 앞단의 queue에 저장되게 된다. 그래서 이 두 개를 모니터링 하면 시스템이 병목 상태인지 아닌지를 판단할 수 있다. 이 값들은 JMX (Java Management Extension) API를 이용하여 모니터링 하면 된다.\n\nDB의 경우에는 slow query를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다. MySQL 5.6의 경우 slow query는 [http://dev.mysql.com/doc/refman/5.6/en/slow\\-query\\-log.html](http://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html)\n\n를 사용하면 쉽게 잡아낼 수 있다.\n\nSlow query를 찾았으면, EXPLAIN 명령어를 이용하여 query 의 수행 내용을 분석한후 Index등의 튜닝을 수행할 수 있다.\n\n[http://dev.mysql.com/doc/refman/5.0/en/using\\-explain.html](http://dev.mysql.com/doc/refman/5.0/en/using-explain.html)\n\n③ 인프라 관점 : CPU, Memory, Network IO, Disk IO\n\n다음으로 하드웨어 인프라에 대한 부분을 지속적으로 모니터링해줘야 하는데, 이는 하드웨어가 해당 성능을 내기 위해서 용량이 충분한지 그리고 하드웨어 구간에서 병목이 생기지는 않는지, 생긴다면 어느 구간에서 생기는지를 모니터링하여, 해당 병목 구간에 대한 문제 해결을 하기 위함이다.\n\n인프라에 대한 모니터링은 Ganglia나 Cacti와 같은 전문화된 인프라 모니터링 도구를 사용하거나 top이나 glance, sar와 같은 기본적인 Unix/Linux 커맨드를 사용해서도 모니터링이 가능하다. (부하 테스트주에 top 등을 띄워놓고 모니터링을 하는 것이 좋다. Load Runner와 같은 상용 도구의 경우에는 부하 테스트 툴 자체에서 테스트 대상 시스템에 대한 하드웨어 사용률을 함께 모니터링할 수 있게 제공해준다.)\n\n**CPU :** 일반적으로 CPU는 대부분 잘 모니터링 한다 . 목표 성능을 달성할 시에는 보통 70~80% 정도의 CPU 를 사용하는 것이 좋고 , 20~30%의 여유는 항상 가지고 가는 것이 좋다 이유는, 70~80% 정도의 CPU가 사용된 후에, 하드웨어를 물리적으로 늘리는 시간에 대한 여유 시간을 가지기 위함이다. 하드웨어는 특성상 주문을한다고 해도 , 바로 그 시간에 증설을 할 수 있는 것이 아니고, CPU 가 100%가 되는 순간에는 이미 애플리케이션이 CPU 부족으로 제대로 작동을 하지 못하는 경우가 많기 때문에, 항상 여유를 남겨 놓고 성능 목표를 정의 하는 것이 좋다 . 그래서 성능 목표를 잡을 때는 “CPU 70%시, 500 TPS, 응답시간 1.5 초 내외” 식으로 하드웨어에 대한 사용률을 포함하는 것을 권장한다.\n\n**Memory :** 다음으로는 Memory 부분이다 . Peak Time 시에 Memory가 얼마나 사용되느냐가 중요한데, Java Application의 경우 특성상, 전체 JVM 프로세스가 사용할 메모리량을 미리 정해놓기 때문에, 부하 테스트 중에도 메모리 사용량 자체는 크게 변화하지 않는다. 다만 자주 놓치는 점이 swapping status 인데, Unix/Linux는 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해서 virtual memory 라는 개념을 사용하고 swapping space라는 디스크 공간에 자주 사용하지 않는 메모리의 내용을 dump해서 저장한 후 다시 사용할때 memory에 loading 하는 방식을 사용한다. 그런데 이 메모리의 내용을 디스크에 저장 및 로드 하는 과정 (swapping이라고 함)이 실제 disk io를 발생 시키기 때문에, 실제 메모리 access 성능이 매우 급격하게 떨어진다. 그래서 시스템에서 system에서 swapping 이 발생하면 시스템의 성능이 장애 수준으로 매우 급격하게 떨어진다.\n\n부하 테스트 중이나, 운영 중에 swapping이 발생하게 되면 전체 메모리 사용량을 줄이도록 튜닝을 하거나, 반대로 물리 메모리를 늘리는 증설 과정이 필요하다.\n\n**Disk IO :** Disk IO는 파일 시스템에 파일을 저장하는 시나리오나, Log를 저장하는 모듈 그리고 데이타 베이스와 같이 뒷단에 파일 시스템을 필요로 하는 모듈에서 많이 발생을 한다. Ganglia와 같은 도구를 사용하면, IOPS (Input Out per Second \\- 초당 read/write 등의 IO 발생 횟수)를 통해서 모니터링할 수 있고, 또는 iostat나 sar와 같은 명령어를 이용하면 iowait 를 통해서 디스크 IO의 pending이 발생할 경우 디스크 병목이 있는지 없는지를 확인할 수 있다.\n\n![](https://t1.daumcdn.net/cfile/tistory/25573944522609991F)\n\nFigure 1 . iostat\n\n또는 Process당 Disk IO는 iotop과 같은 툴을 사용하면 조금 더 상세한 정보를 얻을 수 있다.\n\n![](https://t1.daumcdn.net/cfile/tistory/23284044522609A533)\n\nFigure 2 . iotop\n\n[\\[1\\]](file:///C:/Users/terry/Desktop/%EB%AC%B8%EC%84%9C/Dropbox/%EC%A1%B0%EB%8C%80%ED%98%91%EC%9D%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C/%EC%9E%91%EC%97%85%EC%A4%91%EC%9D%B8%20%EC%B1%95%ED%84%B0/8%EC%9E%A5%20%EC%84%B1%EB%8A%A5%20%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-130824.docx#_ftn1)\n\nDisk IO에 대한 Bottleneck은 여러가지 해결 방법이 있다. 먼저 하드웨어 인프라 ㅈ체에서 접근 하는 방식은, 디스크 자체를 SSD로 변경하거나 , 버퍼가 크거나 RPM이 높은 디스크로 변경하는 방식, 인터페이스를 SATA에서 SAS나 SSD와 같은 높은 IO를 제공하는 디스크 인터페이스로 변경, Disk Controller는 iSCSI에서 FC/HBA와 같은 광케이블 기반의 고속 컨트롤러를 사용하는 방식 또는 RAID 구성을 Stripping 방식으로 변경해서 IO를 여러 디스크로 분산 시키는 방식 등이 있으며, 애플리케이션 차원에서는 데이타 베이스 앞에 memcache와 같은 캐슁을 사용하거나, 로깅의 경우에는 중간에 message queue를 써서 로그를 다른 서버에서 쓰도록 하여 IO를 분산하거나 또는 Back write와 같은 방식으로 로그 메세지가 발생할때 마다 disk에 writing 하는 것이 아니라 20개 30개씩 한꺼번에 디스크로 flushing 하는 방식등을 이용할 수 있다.\n\n또는 조금더 높은 아키텍쳐 레벨로는 디스크 IO가 많이 발생하는 로직의 경우 동기 처리에서 message queue를 사용하는 비동기 방식으로 시스템의 설계를 변경하는 방법을 고민할 수 있다 . 예를 들어 사진을 올려서 변환하는 서비스의 경우 파일을 업로드 하는 시나리오와 변경하는 모듈을 물리적으로 분리하여, 파일 업로드가 끝나면 , 사용자에게 동기 방식으로 바로 응답을 줘서 응답 시간을 빠르게 하고, 업로드된 파일은 뒷단에서 비동기 프로세스를 통해서 변환 과정을 다 끝낸 후에 사용자에게 변환이 끝나면 알려주는 방법을 사용할 수 있다.\n\nNetwork IO: Network IO는 특히 고용량의 파일이나 이미지 전송에서 병목이 많이 발생하며, Reverse Proxy, NAT (Network address Translator), Router, Load Balancer 등에서 많이 발생한다. 여러가지 지점과 장비에 대해서 모니터링 해야 하기 때문에, 일반적인 unix/linux command 를 사용하는 방법보다는 Cacti나 Ganglia와 같은 RRD 툴이나 OpenNMS와 같은 NMS (Network Management System)을 사용하는게 좋다.\n\n그래프를 보면서 추이를 지켜 보는 것이 중요한데, 부하를 넣으면 일정 수준이 되어도, 시스템들의 CPU 나 메모리, Disk등의 기타 자원들은 넉넉한데, Network Input/Output이 일정 수준 이상으로 올라가지 않는 경우가 있다. 이 경우는 네트워크 구간의 병목일 가능성이 높다.\n\n특히 소프트웨어 기반의 Load Balancer나, 소프트웨어 기반의 NAT 장비에서 많이 발생하는데, 이미지와 같은 정적 컨텐츠는 가급적이면 CDN이나 분리된 Web Server를 이용해서 서비스 하도록 하는 것이 좋다. 클라우드의 경우에는 특히나 소프트웨어 기반의 NAT나 Load Balancer 를 사용해서 문제가 되는 경우가 많은데, NAT의 경우에는 여러개의 NAT를 사용해서 로드를 분산하도록 하고 , Load Balancer의 경우에도 충분히 큰 용량을 사용하거나 2개 이상의 Load Balancer를 배포한 후 DNS Round Robine등을 사용하는 방법을 고려 하는 것이 좋다.\n\n### 개선 (Tuning)\n\n병목을 찾았으면, 해당 병목 문제를 해결 및 반영해야 한다.\n\n튜닝은 병목 구간이 발생하는 부분에 대한 전문적인 지식을 필요로 하지만, 기본적인 접근 방법은 거의 같다고 보면 된다.\n\n① 문제의 정의 : 성능 개선의 가장 기본은 문제 자체를 제대로 정의 하는 것이다. “그냥 느려요”가 아니라, “ 성능 목표가 350TPS에 1초내의 응답 시간인데, 현재 60 TPS에 5 초의 응답 시간에 WAS의 CPU 점유율이 100% 입니다.”와 같이 명확해야 하며, 문제점이 재현 가능해야 한다.\n\n특히 재현 가능성은 매우 중요한 점인데, 테스트 환경이 잘못되었거나, 외부적 요인 예를 들어 부하 테스트 당시 네트워크 회선이 다른 테스트로 인하여 대역폭이 충분히 나오지 않았거나 했을 경우 결과가 그 때마다 다르게 나올 수 있다.\n\n즉 문제 자체를 명확하게 정의할 필요가 있다.\n\n② Break down : 다음으로는 문제가 발생하는 부분이 어떤 부분인지를 판단해야 한다. 시스템은 앞단의 로드밸런서나 미들웨어, 데이타 베이스와 같은 여러 구간에서 발생을 한다 . 그렇기 때문에, 성능 저하의 원인이 정확하게 어느 부분인지를 인지하려면, 먼저 성능 시나리오가 어떤 어떤 컴포넌트를 거치는지를 명확하게 할 필요가 있다. 이 과정을 break down 이라고 한다. 이 과정을 통해서 전체 성능 구간중, 어느 구간이 문제를 발생 하는지를 정의한다.\n\n③ Isolate : 다음으로는 다른 요인들을 막기 위해서, 문제가 되는 구간을 다른 요인으로 부터 분리 (고립) 시킨다. 물론 완벽한 분리는 어렵다. 애플리케이션이 동작하기 위해서는 데이타 베이스가 필수적으로 필요하다 . 이 경우에는 데이타 베이스를 분리할 수 는 없다. 그러나 예를 들어 시나리오 자체가 로그인 시나리오이고 Single Sign On을 통해서 로그인 하는 시나리오라서 SSO 시스템과 연동이 되어 있다면, SSO 연동을 빼고 다른 mock up을 넣어서 SSO와의 연결성을 끊고 테스트를 하는 것이 좋다.\n\n이렇게 문제에 대한 다른 요인과의 연관성을 최대한 제거 하는 작업이 isolation이다.\n\n④ Narrow down : 문제를 isolation을 시켰으면 , 근본적인 문제를 찾기 위해서 문제의 원인을 파 내려간다. Profiling을 하거나, 코드에 디버그 정보를 걸어서 문제의 원인을 분석하는 과정을 narrow down이라고 한다. 특히나 이 narrow down 과정은 분석을 위한 여러가지 기법이나 도구들을 사용해야 하고, 현상에 대한 이해를 하기 위해서는 해당 솔루션이나 기술 분야에 대한 전문성은 필수적으로 필요하다.\n\n⑤ Bottleneck 발견 : Narrow down을 해서 문제의 원인을 계속 파해쳐 나가면 병목의 원인이 되는 근본적인 문제가 판별이 된다.\n\n⑥ 해결 : 일단 병목의 원인을 찾으면 해결을 해야 하는데, 찾았다고 모두 해결이 되는건 아니다. 데이타 베이스 index 를 걸지 않아서 index를 걸어주면 되는 간단한 문제도 있을 수 있지만, 근본적인 솔루션 특성이나 설계상의 오류로 인해서 문제가 발생하는 경우도 있다. 하드웨어를 늘려서 해결하는 방법도 있지만 , 비지니스 시나리오 자체를 바꾸거나 UX 관점에서 해결 하는 방법도 고려할 수 있다. 예를 들어 로그인 화면이 넘어가는데 시간이 많이 걸린다고 했을때, 이 문제가 근본적으로 솔루션의 특성이라면 애플리케이션이나 솔루션 수정으로는 해결이 불가능하다. 이런 경우에는 모래 시계 아이콘이나 progress bar등을 넣어서 UX 관점에서 사용자로 하여금 체감되는 응답 시간에 대해서 느리지 않고 몬가 진행이 되고 있다고 보여주는 형태로 접근을 해서 문제를 해결할 수 도 있다.\n\n간단한 예를 하나 들어보자. Drupal 이라는 웹 CMS 기반의 웹사이트가 있다고 하자. 성능 테스트를 수행하였는데, CPU 점유율이 지나치게 높게 나오고 응답 시간이 느리게 나왔다 . 이것이 문제의 정의이다.\n\n성능의 문제점을 찾아내기 위해서, 성능 테스트 시나리오를 검토하였다 성능 테스트 시나리오는 1) 로그인 페이지 로딩, 2) id,password를 post로 전송 3) 초기 화면으로 redirect됨 4) 로그 아웃 4 가지 과정을 거치고 있었다. 1,2,3,4 과정의 응답시간을 각각 체크해서 보니, 2) 과정에서 성능의 대부분을 차지 하고 있음을 찾아 내었다. 전체적으로 성능이 안나오는 것을 인지한 후 , 문제를 여러 구간으로 나누어서 접근 하는 것이 Break down이다.\n\n2. 과정을 분석하기 위해서 성능 테스트를 다시 진행한다. 다른 시나리오가 영향을 주는 것을 방지하기 위해서 , 1,3,4 시나리오를 제외 하고, 2 시나리오만 가지고 성능 테스트를 진행한다. 이렇게 문제점을 다른 변수로 부터 분리하여 고립 시키는 것을 isolation이라고 한다.\n\n다음으로 Xhprof 라는 프로파일링 툴을 사용하여 로직중 어느 부분이 가장 성능 문제가 발생하는 지를 profiling 하였다. 대 부분의 성능 저하가 SQL 문장 수행에서 발생함을 찾아내었다. 이렇게 하나의 포인트를 깊게 들어 가면서 범위를 좁혀가는 것을 narrow down이라고 한다.\n\nSQL 수행이 문제가 있음을 정의하고(문제의 정의 ), 어떤 SQL 문장이 수행되는지(Break down) 각각을 정의한후, 가장 수행 시간이 긴 SQL 문장을 찾아서 원인을 분석하였더니(narrow down) index 가 걸려 있지 않음을 찾아내었다.\n\n해당 테이블에 index를 적용하고, 성능 테스트를 다시 수행하여 성능 목표치를 달성하였음을 해결하였다.\n\n가상의 시나리오지만 성능 튜닝의 접근 방법은 대부분 유사 하다. 관건은 문제를 어떻게 잘 정의하고, 문제가 어떤 요소로 구성이 되어 있으며 각각이 어떤 구조로 동작을 하고 있는지 잘 파고 들어갈 수 있는 문제에 대한 접근 능력과, 점점 솔루션의 아랫부분(low level)로 들어갈 수 있는 전문성이 필요하다.\n\n### 반복\n\n튜닝이 끝났으면 다시 “테스트 및 모니터링” 항목으로 돌아가서 성능 목표에 도달할때까지 위의 작업을 계속해서 반복해서 수행한다.\n\n## Performance Engineering을 위해 필요한 것들\n\n그러면 성능 엔지니어링을 하기 위해서 필요한 것들은 무엇이 있을까? 먼저 도구 적인 측면부터 살펴보자.\n\n① 부하 테스트기 : 가장 기초적으로 필요한 것은 부하 발생 도구 이다. HP Load Runner와 같은 상용 도구에서 부터, nGrinder와 같은 오픈 소스 기반의 대규모 부하 발생 도구를 사용할 수 도 있고 , SOAP UI같은 micro benchmark 테스트 툴을 이용해서 소규모 (50 사용자 정도)를 발생 시키거나 필요에 따라서는 간단하게 Python등의 스크립트 언어로 부하를 발생시킬 수 도 있다.\n\n② 모니터링 도구 : 다음으로는 모니터링 도구이다. 어느 구간이 문제가 있는지 현상이 어떤지를 파악하려면 여러 형태의 모니터링 도구들이 필요하다.\n\n③ 프로파일링 도구 : 그리고, 문제되는 부분을 발견했을때 , 그 문제에 대한 근본적인 원인을 찾기 위해서 프로파일링을 할 수 있는 도구들이 필요하다.\n\n우리가 일반적으로 이야기 하는 프로파일링 도구들은 IDE와 같은 개발툴에서 debug 용도로 사용은 가능하지만, 대부분 대규모 부하 환경에서는 사용이 불가능한 경우가 많다.그래서 그런 경우에는 해당 시스템의 상태에 대한 스냅샷을 추출 할 수 있는 dump 도구들을 많이 사용하는데 , unix process의 경우에는 ptrace를 통해서 system call 을 모니터링 하거나, pmap을 이용하여 메모리 snapshot등을 추출할 수 도 있고 , 자바의 경우에는 thread dump를 추출해서 병목 당시 애플리케이션이 무슨 동작을 하고 있었는지를 찾아낼 수 있다.\n\n다음이 이 글에서 정말 언급하고 싶은 내용인데, 앞에서 도구를 언급했다면 다음은 엔지니어로써의 역량이나 지식적인 부분이다.\n\n④ 역량 : 당연한 것이겠지만, 기술적인 역량은 필수적이다 . netstat를 통해서 TCP 소켓이 FIN_WAIT 가 발생하였는데, 이 FIN_WAIT가 의미하는 것이 무엇인지 모르면 아무리 모니터링을 잘해도 소용이 없다. 기본적인 엔지니어로써의 컴퓨터와 프로그래밍, OS등에 대한 넓은 이해는 필수적이다.\n\n⑤ 하드웨어 인프라, 미들웨어 , 애플리케이션에 대한 지식 : 다음은 사용하는 특정 솔루션에 대한 전문적인 지식이다. 톰캣의 내부 구조가 어떻게 되어 있으며, JVM의 동작원리가 어떻게 되는지와 같은 특정 지식인데, 사실 이러한 지식은 오랜 경험이나 습득할 시간이 없으면 가지기가 어렵다. 이런 경우는 해당 솔루션 제품 엔지니어를 통해서 지원을 받는 방법도 고려해볼만 하다.\n\n⑥ 그리고 경험 : 성능 엔지니어링에 대한 경험인데, 대략 시스템의 상태마 봐도 어느 부분이 의심이 되는지 경험이 많은 엔지니어는 쉽게 접근을 한다. 성능 문제는 넓어보이기는 하지만, 결국 발생되는 패턴이 거의 일정하다. 그리고 특정 솔루션에 대한 지식이 없다하더라도, 문제에 대한 접근 하는 방법이나 모니터링 방법, 툴등은 사용법이 다르다 하더라도 그 의미하는 방법은 거의 비슷하기 때문에, 다른 기술로 구현되어 있는 시스템이라고 하더라도 , 경험이 있는 엔지니어는 문제를 접근해서 풀어나가는 방식이 매우 익숙하다.\n\n⑦ 마지막으로 인내심 : 그리고 마지막으로 강조하고 싶은 점이 인내심인데, 사실 성능 엔지니어링은 상당히 지루한 작업이다. 반복적인 테스트와 모니터링 및 분석을 거쳐야 하고, 해당 솔루션에 대한 전문적인 지식이 없을 경우에는 보통 제품 문제라고 치부하고 하드웨어 업그레이드로 가는 경우가 많은데, 어짜피 솔루션이라고 해도 소스코드로 만들어진 프로그램이다. 디컴파일을 하건, 덤프를 추출하건, 꾸준히 보고, 오픈 소스의 경우 소스코드를 참고해서 로직을 따라가다 보변, 풀어낼 수 있는 문제가 대부분이다. 결국은 시간과 인내심의 싸움인데, 꾸준하게 인내심을 가지고 문제를 접근하고 풀어나가는 것을 반복하면 문제는 풀린다.\n\n## 참고자료\n\n[조대협 블로그](https://bcho.tistory.com/787)\n"},"html":"<h1 id=\"성능-엔지니어링에-대한-접근-방법\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95\" aria-label=\"성능 엔지니어링에 대한 접근 방법 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능 엔지니어링에 대한 접근 방법</h1>\n<p>성능 개선, Performance Tuning, 용량 선정 과 같은 튜닝 관련 용어들은 모든 개발자나 엔지니어에게 모두 흥미가 가는 주제일 것이다. 그 만큼 소프트웨어에서 고성능을 내는 시스템은 만들기도 힘들뿐더러, 고성능 시스템이란 즉 잘 설계되고 구현된 소프트웨어를 뜻하는 것이니 관심을 가지는 것이 당연하지 않을까 싶다.</p>\n<p>필자의 경우, 엔터프라이즈 시스템에 대한 약 6년간 장애 해결 , 장애 회피 설계, 성능 개선, 고성능 시스템 설계 및 구현에 관련된 일을 해왔다. 특히 장애 해결과 성능 개선 작업은 하고 나면 뿌듯하기는 하지만, 특정한 기술이 필요하기 보다는 문제를 정의하고 접근하는 능력과 끝까지 목표를 달성할 때까지 지루한 작업을 반복적으로 할 수 있는 인내심을 필요로 하는 작업이다</p>\n<p>이번 챕터에서는 Performance Engineering의 전반적인 접근 방법과, 용량 산정 방법 그리고 자바 기반의 서버 애플리케이션에 대한 성능 튜닝 및 병목 발견 방법에 대해서 설명하고자 한다.</p>\n<h1 id=\"performance-engineering-의-정의와-범위\" style=\"position:relative;\"><a href=\"#performance-engineering-%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EB%B2%94%EC%9C%84\" aria-label=\"performance engineering 의 정의와 범위 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Performance Engineering 의 정의와 범위</h1>\n<p>Performance Engineering은 시스템의 목표 성능 (응답 시간과 동시 접속자수) 을 정의 하고, 이를 달성하기 위해서, 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.</p>\n<p>좁게 생각하면, 코드상의 병목을 잡고, 시스템의 설정 (Configuration)을 바꿔서 성능을 올리는 튜닝으로 생각할 수 있지만, 성능 목표의 정의에서 부터, 최적의 성능을 내기 위한 디자인 및 구현과 같은 개발 초기의 설계 부분와 개발후의 운영단계에서 모니터링 까지 전과정을 포함한다.</p>\n<h2 id=\"performance-engineering은-언제-해야-하는가\" style=\"position:relative;\"><a href=\"#performance-engineering%EC%9D%80-%EC%96%B8%EC%A0%9C-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"performance engineering은 언제 해야 하는가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Performance Engineering은 언제 해야 하는가?</h2>\n<p>Performance Engineering은 전체 소프트웨어 개발 과정에 걸쳐서 크게 아래와 같이 4단계에 걸쳐서 일어난다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/234FEE405226094801\" alt=\"\"></p>\n<p>위의 개발 모델은 전형적인 Water fall model이다. 개발프로세스 챕터에서도 설명하였지만 , 스크럼과 같은 애자일 방법론을 사용하더라도 큰 범위에서 개발 사이클은 Waterfall 모델과 크게 다르지 않게 된다. (각 단계별을 SPRINT 단위로 수행한다.)</p>\n<p>① 분석 단계</p>\n<p>초기 요구 사항 분석 및 시스템 기획 단계에서는 성능에 대한 목표를 정해야 한다.</p>\n<p>목표 응답시간은 어떻게 되는지, 시스템을 사용할 총 사용자수와 동시에 시스템을 사용하는 동시접속자 수가 어떻게 되는지와 같은 성능 목표를 정의한다.</p>\n<p>또한 고려해야 하는 사항중의 하나는 성능 모델이다. 시스템에 부하가 어떤 패턴으로 들어오는지를 정의할 필요가 있다.</p>\n<p>예를 들어 일반적인 웹컨텐츠 사이트의 경우 사용자가 들어와서 페이지 컨텐츠를 1<del>3분 내에 읽고 다른 페이지로 이동하다가, 20 여분 후에는 로그아웃하거나 다른 사이트로 이동한다. 즉 한 사용자의 체류 시간은 20분정도되며, 총 평균 20 페이지를 보는 트렌젝션을 발생 시키고 나간다고 할 수 있다. 한글로 만든 사이트이고, 육아나 주부를 대상으로 한 사이트라고 가정하면, 시스템의 부하는 한국 시간으로 아이들이 학교나 유치원을 간후인 10시</del>11시와, 저녁시간대인 10시~12시 사이에 몰린다고 가정할 수 있다.</p>\n<p>다른 예로 게임 시스템을 예로 들어보자, 주로 초등학생을 타켓으로 한 게임이라면, 방과후 시간인 3 시<del>5시 대에 부하가 가장 몰릴 것이며, 게임의 종류에 따라 다르겠지만, 스타크래프트와 같은 게임의 경우 한번 플레이에 40분 정도 소요가 되고, 한 사용자가 하루에 두번정도 게임을 한다 가정 아래, 사용자당 체류 시간은 2시간, 게임 횟수는 2회/일. 그리고 주요 부하는 3</del>5시 오후대 라는 성능 모델을 만들 수 있다.</p>\n<p>초기 성능 정의는 서비스의 종류(웹,게임, 기업 시스템,쇼핑,뱅킹등) 나, 서비스를 사용하는 사용자층, 그리고 서비스를 사용하는 지역. 즉 전세계를 서비스하는 시스템이라면 시스템의 부하는 365일 ,24시간 거의 다 걸린다고 봐야 한다. 그러나 한국만을 대상으로 서비스 하는 한국어로 된 사이트인 경우, 새벽 시간에는 일반적으로 로드가 없는 것과 같은 한국의 시간대에 영향을 받을 뿐만 아리나 명절,휴일,휴가와 같은 한국이라는 국가 특성에 따라 시스템의 부하가 영향을 받는다.</p>\n<p>② 디자인 단계</p>\n<p>다음으로는 디자인 단계에서는 목표 성능과 용량을 달성할 수 있는 규모의 시스템으로 설계를 진행한다.</p>\n<p>성능 관점에서 시스템 디자인은 항상 Peak Time (최대 성능)에 맞춰서 디자인이 된다. 최대 성능을 기반으로 전체 시스템이 받아낼 수 있는 용량과 응답 시간을 고려해야 한다.</p>\n<p>특히 성능과 용량은 애플리케이션 디자인 뿐만 아니라 Technology selection에도 많은 영향을 받는다. 어떤 하드웨어를 사용할 것인지, 어떤 미들웨어나 프레임웍을 사용할 것인지이에 따라 용량과 성능의 차이가 많이 발생하기 때문에, 디자인 단계에서 부터 성능과 용량을 감안해서 시스템을 설계해야 한다.</p>\n<p><strong>하드웨어 관점</strong>에서는 예전에는 성능 모델을 산정한 후에, Peak Time 기준 ( 최대 성능 요구)으로 시스템을 설계하고, 하드웨어를 구매 하였으나, 근래에는 클라우드를 이용하여 필요시에만 하드웨어를 탄력적으로 사용하는 Auto Scale Out 모델을 많이 사용한다.</p>\n<p>기업 내부의 업무 처럼 (예를 들어 이메일), 부하가 일정하고 예측이 가능한 경우에는 Fixed 된 사이즈의 하드웨어를 사용하도록 설계 하고, 출시 이벤트 행사 사이트와 같이 부하가 갑자기 몰리는 시스템의 경우 클라우드를 고려해보는 것도 권장할만 하다.</p>\n<p>또한 빠른 응답 시간이 필요할 경우 SSD 디스크를 사용하거나, RAID 구성도 5 보다는 1+0 등을 고려하는 등, 성능 모델에 따라서 적절한 하드웨어 선정과 구성 설계가 필요하다.</p>\n<p><strong>미들웨어</strong>나 프레임웍 관점에서도 정의된 성능 모델에 따라 적절한 제품군과 설계 구조를 채택해야 한다 . 100,000 사용자 정도의 시스템 규모에서는 RDBMS 를 사용해도 성능이나 용량상에 문제가 없다. 그러나 50,000,000 사용자 정도를 지원해야 하는 시스템의 경우 그냥 RDBMS 를 사용할 수 없다. Sharding이나, NoSQL 과 같은 다른 차원의 접근이 필요하다.</p>\n<p>또한 빠른 응답 시간을 요구하는 경우 Redis나 Memcached와 같은 Cache 솔루션을 적극적으로 활용하거나, 미들웨어 부분에서는 Tomcat과 같은 일반적은 Web Application Server 보다는 Netty나 Vertex와 같은 고성능 미들웨어를 고려해볼 수 있다.</p>\n<p>이러한 성능이나 용량에 관련된 제품 선정이나 설계는 돌려 보지 않으면 사실 확신을 가지기 어렵다. 그래서 가능하면, Technology selection 후에 , 간단한 프로토타입을 구현한후에 시나리오가 단순한 대규모의 성능 및 용량 테스트를 해보는 PoC (Proof Of Concept)과 같은 작업을 이 단계에서 수행하는 것을 권장한다.</p>\n<p>③ 개발단계</p>\n<p>개발 단계는 개발프로세스 챕터에서 설명하였듯이, risk 가 높은 부분과 아키텍쳐에 관련되는 부분, 난이도가 높은 부분 , 핵심 기능등을 개발 초기의 스프린트에서 개발한다.</p>\n<p>초기 스프린트가 끝나고 릴리즈가 되서 성능 테스트가 가능한 QA나 스테이징 환경으로 시스템이 이전되면, Performance Engineering 역량을 이 단계에 집중하여 , 시스템의 아키텍쳐와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 수행한다.</p>\n<p>초기 단계에 성능 목표의 달성 가능 여부가 판단되어야, 아키텍쳐 변경이 가능하고, 주요 성능 이슈들을 초반에 발견해야 , 발견된 성능 문제들에 대해서는 같은 문제가 발생하지 않도록 디자인 가이드나 코딩 가이드를 개발자들에게 배포하여 성능에 대한 위험도를 줄일 수 있다.</p>\n<p>④ 최종 테스트 단계</p>\n<p>앞의 단계에서 성능과 용량을 고려해서 설계가 되었고, 개발 초기 단계에서 성능과 용량 부분을 검증을 제대로 하였다면, 최종 테스트 단계에서는 개발된 최종 시스템에 대한 성능과 용량 부분의 측정과 미세 튜닝 (애플리케이션의 병목을 찾아서 부분적으로 수정하거나 , 하드웨어나 미들웨어의 Configuration 하는 수준)을 하는 정도로 마무리가 되어야 한다.</p>\n<p>이 과정에서는 실수로 잘못한 설정(configuration) 이나 잘못된 코딩으로 된 부분에 대해서 검증이 이뤄지는데, 이 경우에는 보통 2배에서 크게는 10 배까지의 성능 향상이 이루어진다. 이런 경우는 대부분 실수에 의한 것이고 성능이 터무니 없이 낮게 나오기 때문에 찾기가 쉽다.</p>\n<p>예를 들어 로그 파일을 NFS와 같은 리모트 디스크에 쓴다던지, Intel 계열의 CPU에서 하이퍼쓰레딩을 ON을 안했다던지와 같이 실수에 의한 경우가 많다.</p>\n<p>이런 오류성의 문제들이 해결되면 실제 미세 튜닝에 들어가게 되는데, JVM 튜닝이나 톰캣의 설정 튜닝, SQL 튜닝들이 이루어지는데 , 이 미세 튜닝을 통해서는 비약적인 성능향상은 이루어나지 않는다. 보통 20% 내외 정도 성능이 올라간다고 보면 된다.</p>\n<p>⑤ 운영 단계</p>\n<p>마지막으로 시스템이 운영 단계로 넘어가게 되면, 테스트시에 발견되지 않은 성능적인 문제가 있을 수 있기 때문에, 모니터링 도구를 사용하여 지속적으로 성능을 모니터링 하고 , 성능상에 문제가 있는 부분을 지속적으로 수정해야 한다. 웹서버의 access로그에서 응답 시간을 모니터링 하거나, 제니퍼(<a href=\"http://www.jennifersoft.com/\">http://www.jennifersoft.com</a> ) 과 같은 전문적인 APM (Application Performance Monitoring)툴이나, Ganglia와 같은 시스템 모니터링 도구를 사용하면, 시스템의 성능 상태를 잘 알 수 있다.</p>\n<p>더불어 용량 부분에 대해서도 운영단에서는 고민을 해야 하는데, 일반적으로 PEAK Time의 시스템 용량이 (CPU) 80% 정도에 다다르면, 시스템 용량 증설을 고려해야 한다.</p>\n<p>그리고 업무에 특성에 맞게 미리미리 용량을 준비해놓는게 좋다. 예를 들어 대학의 수강 신청 시스템의 경우, 학기 시작하는 날에 부하가 폭주하기 때문에, 클라우드 기반일 경우 수강신청 전에 시스템 수를 미리 늘려놓는다던지, 클라우드가 아닌 경우, 수강 신청 기간을 앞뒤로 서버를 임대해서 용량을 늘려놓는 등의 대책을 미리 세워놓을 수 있다.</p>\n<p>마지막으로, 운영 단계에서 Performance Engineering 관점으로 챙겨야 하는 부분은 운영 로그의 수집이다. 성능 및 용량 목표 설정은 매우 중요한 과정이다. 특히 용량 목표의 경우에는 기존의 업무 시스템의 사용 패턴을 분석 하는 것이 가장 효율적이기 때문에 운영 시스템의 로그를 수집하고 분석하여 운영 중인 업무 시스템의 성능 모델을 분석 및 보유 해놓는 것이 좋다.</p>\n<h2 id=\"시스템-용량-산정-capacity-planning\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9A%A9%EB%9F%89-%EC%82%B0%EC%A0%95-capacity-planning\" aria-label=\"시스템 용량 산정 capacity planning permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템 용량 산정 (Capacity Planning)</h2>\n<p>더 자세한 설명에 들어가기 앞서서, 성능에 관련된 용어와 함께 시스템의 목표 용량 산정 방법에 대해서 이야기 해보도록 하자.이 용어는 이 글에서 정의하는 의미의 용어이며, 다른 성능 이론에서 언급되는 용어와 다소 다를 수 있다.</p>\n<p>l <strong>Response Time (응답 시간) :</strong> 사용자가 서버에 요청을 한 시간에서 부터 , 응답을 받을 때 까지의 모든 시간을 포함한다. 이 응답시간은 내부적으로 다음과 같이 조금 더 세분하게 분리된다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/27427E435226095A1B\" alt=\"\"></p>\n<p>Network Time (또는 Latency time). 서버에 요청을 했을때, Request를 보내고 받을 때 소요되는 네트워크 시간을 의미한다.</p>\n<p>Transaction Time : 서버에서 실제 트렉젝션이 처리되는 시간을 의미 한다.</p>\n<p>Think Time : 사용자가 요청에 대해서 응답을 받은 후에, 웹페이지를 보거나 화면을 보는 등의 작업을 하는 시간의 의미한다.</p>\n<p>예를 들어 보면 한국의 사용자가 미국이 페이스북을 사용한다고 했을때, 사용자가 웹 브라우져에서 클릭을 하면, 요청이 서버로 도달할때 까지 걸리는 시간 Network time (Request), 서버가 요청을 받아서 처리를 하고, 응답을 하는 시간 (Transaction Time), 그리고 그 응답이 사용자의 브라우져 까지 도착하는 시간이 Network time (Response) 이다. 이 전체 시간을 합친 것이 Response Time 이 된다.</p>\n<p>응답을 받은 후에는 사용자가 페이스북 내용을 보는데 소요 되는 시간이 Think Time이 된다.</p>\n<p>Think Time 까지 포함하여 다음 요청이 발생하기 까지의 전체 시간을 Request Interval 이라고 한다.</p>\n<p>l <strong>Concurrent User (동시 사용자) :</strong> 시스템을 현재 사용하고 있는 사용자를 정의한다. 웹사이트를 사용하기 위해서, 현재 브라우져를 열어놓고 웹사이트를 보고 있는 것과 같이 현재 시스템을 사용하고 있는 사용자 수를 의미 한다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/232F2044522609672F\" alt=\"\"></p>\n<p>위의 그림을 보자, 5명의 사용자 A~E가 있다고 가정했을 때, 단위 시간 10분동안에 Transaction Time 과 Think Time중에 있는 사용자는 A,B,C 총 3명으로 해다 시간 10 분간의 Concurrent User는 3명이 된다.</p>\n<p>l Active User (액티브 사용자) : 현재 시스템에 트렌젝션을 실행하여 부하를 주고 있는 사용자를 정의한다.</p>\n<p>기존에는 Concurrent User와 Active User간의 차이가 없었다. 이 개념은 웹이 생기면서 구체화된 개념인데, 웹 사이트를 사용하기 위해서 컴퓨터 앞에 앉아 있는다고 하더라도, 웹 페이지가 로딩 되는 순간에만 서버는 부하를 받고, 페이지가 웹 브라우져로딩 된 후에는 부하를 받지 않고 사용자는 로딩된 페이지를 보는데 시간이 발생한다. 이 시간동안에는 서버는 부하를 받지 않는다. 즉 시스템을 사용하기 위해서 웹 사이트를 열어 놓고 있는다 하더라도 지속적으로 서버에 부하를 주는 것이 아니기 때문에 Concurrent User와 Active User 의 개념 차이가 발생한다.</p>\n<p>Active User는 클릭을 발생시켜서 그 시간 당시에 서버에 트렌젝션을 발생 시키는 사용자를 의미한다.</p>\n<p>Active User의 수는 서버에서 순간 실행되고 있는 Thread 수 ( 쓰레딩 기반의 자바 서버의 경우) 나 Process의 수와 같다. 이 Active User의 수는 실제로 서버가 동시에 처리할 수 있는 트렌젝션의 양을 판단할 수 있는 기준이 되기 때문에 매우 중요한 성능 Factor가 된다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/24653E3F5226097221\" alt=\"\"></p>\n<p>위의 그림을 보자, 위의 그림에서 특정 순간에 있는 사용자는 총 5 명으로 Concurrent User 는 5명이지만, Transaction Time 구간중의 있는 사용자는 A,B,C 로, 총 Active User는 3 명이 된다 .</p>\n<p>l Transaction (트렌젝션) : Transaction이란, 사용자로 부터의 요청을 다루는 단위를 정의 한다. 이 정의가 상당히 중요한데, 성능 모델링이나 성능 테스트 시 이 Transaction의 정의에 따라서 시스템의 성능이 매우 다르게 정의 된다.</p>\n<p>예를 들어서 사용자가 웹 페이지를 클릭했을때, 그 페이지에 대한 응답을 받는 것 까지를 하나의 트렌젝션이라고 정의 하자.</p>\n<p>이 때, 웹페이지에는 서버에서 생생된 HTML 이외에, 여기서 참고 하는 리소스 즉, 이미지나 동영상, 자바 스크립트들이 들어있을 수 있다. 이 경우 트렌젝션에 대한 응답 시간을 측정할때, HTML 생성 이외에 이러한 리소스들을 로딩 하는 것 까지 하나의 트렌젝션으로 정의 해야 하느냐를 고려해야 한다.리소스에 로딩을 트렌젝션의 범위로 넣게 되면 전체 시스템의 응답 시간은 떨어지게 된다. (리소스를 로딩할 때 까지 기다려야 하니).</p>\n<p>이러한 트렌젝션의 정의는 무엇을 판단 기준으로 할것인가에 따라 결정이 되는데, 예를 들어 리소스를 톰캣과 같은 WAS에서 처리하지 않고 앞단의 CDN이나 웹서버에서 처리할 경우 톰캣은 리소스에 대한 트렌젝션 요청을 받지 않기 때문에, 전체 시스템에서 비지니스 로직에 대한 처리 성능을 측정하고자 할 때는 리소스에 대한 로딩 시간을 계산하지 않고 트렌젝션을 정의 한다. 또한 리소스에 대한 로딩은 비지니스 로직에 대한 처리에 비해서 부하가 상대적으로 매우 적고, 일반적으로 브라우져에 캐쉬되기 때문에 보통 서버의 성능 측정시 이러한 리소스 로딩에 대한 부하는 트렌젝션의 단위로 처리하지 않는 경우가 많다.</p>\n<p>l TPS(Transaction Per Second) : 초당 처리할 수 있는 트렌젝션의 양을 정의 한다. 주로 서버의 성능 평가 기준이 된다.</p>\n<p>Active 사용자가 순간 Transaction을 처리한다고 하면, 이를 목표 응답시간 (Response Time)으로 나눈 값이 목표 TPS가 된다. 예를 들어, Active User가 50 명이고, 개당 Response Time이 2초 라고 하면, 이 시스템의 TPS는 25 TPS가 된다.\n※ Network time이 미세하다고 판단하여, Network time을 0으로 가정하여 계산</p>\n<p>l HPS(Hit Per Second) : 시스템이 처리할 수 있는 모든 웹 request의 초당 처리량이다. TPS가 비지니스 트렌젝션에 대한 처리 시간만을 정의 한다면, HPS는 리소스 (이미지, 자바스크립트)에 대한 request 처리량을 포함하기 때문에, TPS에 비해서 10~20 배 정도 높게 나온다.</p>\n<p>l Peak Time(피크 타임) : 서버가 순간적으로 가장 부하를 많이 받는 순간을 정의 한다. 보통 서버의 용량 산정이나 성능 설계는 이 시간의 부하량을 기준으로 한다</p>\n<p>일반적인 업무 시스템의 경우, 출근 9시~9 시30분 사이가 가장 부하가 높다. 이 때 Peak (최고 정점)을 찍는 순간의 동시 사용자 수와 기준 응답 시간을 목표로 성능 목표를 정의 하는 것이 일반적이다.</p>\n<p>위의 개념을 정리해서 공식화 해보자.</p>\n<p>① TPS = (Active User) / (Average Response Time) – F1</p>\n<p>② TPS = (Concurrent User) / (Request Interval) – F2</p>\n<p>③ Active User = TPS * (Average Response Time) – F3</p>\n<p>④ Active User = (Concurrent User) * (Average Response Time) / (Request Interval) – F4</p>\n<p>⑤ Active User = (Concurrent User) * (Average Response Time) / [ (Average Response Time) + (Average Think Time) ] – F5</p>\n<p>예를 들어 Concurrent User가 300명이고, 목표 응답시간이 3초 이내이며, Think Time이 15초 인 시스템의 경우 , F5 공식에 따라서 Active User는 300*3/(3+15) = 50 이 되며 , 시스템의 Thread 또는 적정 Process 양은 50개가 된다. 목표 TPS는 약 16.6 TPS가 된다.</p>\n<p>위의 공식은 어디까지나 이론적인 공식이다. Network Latency 값은 가변적이며, Think Time 또한 유동적이다. 그러나 용량 산정에는 어느 정도의 산정 기준이 필요하기 때문에, 이 공식을 사용하면 대략적인 시스템에 대한 요구 용량을 예측할 수 있다.</p>\n<h2 id=\"performance-engineering-의-절차\" style=\"position:relative;\"><a href=\"#performance-engineering-%EC%9D%98-%EC%A0%88%EC%B0%A8\" aria-label=\"performance engineering 의 절차 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Performance Engineering 의 절차</h2>\n<p>그러면 어떤 절차로 성능과 용량을 측정하고 개선하는 절차에 대해서 알아보도록 하자.</p>\n<h3 id=\"성능-목표와-모델의-정의\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EB%AA%A9%ED%91%9C%EC%99%80-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-label=\"성능 목표와 모델의 정의 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능 목표와 모델의 정의</h3>\n<p>먼저 주요 업무 패턴이나, 튜닝의 대상이 되는 시나리오에 대한 개별 성능 목표를 정의 한다. 예를 들어 전체 성능 목표가 1,000 동시 사용자에 대해서 응답 시간 1초내의 시스템이 전체 성능 목표라고 가정하고, 전체 성능 목표를 대략 1,000 TPS (Transaction Per Second) 라고 하자. 이것이 바로 성능 목표가 된다.</p>\n<p>다음으로 성능 모델을 정의 해야 하는데, 해당 시스템의 주요 사용자 시나리오가 여러개 있을 때, 각 시나리오별의 사용 비중을 정의 해야 한다.</p>\n<p>예를 들어 사진을 저장하는 클라우드 서비스 시나리오가 있다고 하면, 이 서비스의 주요 사용자 시나리오는</p>\n<p>① 로그인</p>\n<p>② 사진 리스트</p>\n<p>③ 사진 업로드</p>\n<p>④ 사진 보기</p>\n<p>⑤ 사진 다운로드</p>\n<p>⑥ 로드 아웃</p>\n<p>등이 된다. 이 중에서 한 사용자가 실행하는 비율을 따져야 한다. 즉 사용자가 로그인 한후 , 리스트 보기를 10번, 업로드를 2번, 보기를 5번 , 그리고 다운로드를 1번 한후에 로그 아웃 한다고 하자. 그러면 비율은 다음과 같이 된다. (전체 트렌젝션 횟수 1+10+2+5+1+1 = 20회)</p>\n<p>성능 모델 :로그인의 비율 5%, 리스트 보기 50%, 업로드 10%, 보기 25%, 로그아웃 5%</p>\n<p>이 비율을 기준으로 복합 시나리오 (전체 시나리오를 함께 돌리는) 부하테스트를 수행하였을때 , 1000 TPS가 나와야 하고, 각 개별 시나리오에 대해서 최소한, 로그인의 경우 1000 TPS의 5%인 50 TPS, 리스트 보기는 500 TPS를 상회 해야 한다.</p>\n<h3 id=\"부하-생성\" style=\"position:relative;\"><a href=\"#%EB%B6%80%ED%95%98-%EC%83%9D%EC%84%B1\" aria-label=\"부하 생성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부하 생성</h3>\n<p>성능 모델이 정의 되었으면, 이 모델에 따라서 부하를 생성해야 한다.</p>\n<p>부하 생성 도구는 여러가지가 있다. 대표적인 오픈 소스 도구로는</p>\n<p>가장 간단하게 쓸 수 있는 도구로는 Apache AB 라는 명령어 기반의 도구가 있으며, 복잡한 스크립트를 지원할 수 있는 도구로는 grinder나 apache JMeter 등이 있으며, NHN에서 grinder를 enhancement해서 만든 (GUI가 지원되는) nGrinder라는 도구가 있다.</p>\n<p>근래에는 국내에서는 nGrinder라는 도구가 많이 사용되고 있다.</p>\n<p>성능 모델이 단순하고, 테스트 시나리오가 간단할 경우에는 Apache ab 등으로도 가능하지만 , 스크립트가 복잡해지는 경우에는 nGrinder와 같은 도구가 유리 하다.</p>\n<p>또한 부하 생성에 사용되는 스크립트는 복잡도가 생각보다 높고, 향후 regression(회귀 ) 테스트에도 재 사용되기 때문에, 반드시 형상 관리 시스템을 통해서 (VCS) 관리 하는 것을 권장한다.</p>\n<p>※ 자세한 부하 테스트에 대한 방법은 “4장 테스트의 시스템 테스트 “ 부분을 참고하기 바란다.</p>\n<p>|</p>\n<p>※ 클라우드 컴퓨팅과 부하 테스트 툴 라이센스 모델에 대해서</p>\n<p>예전에는 부하 테스트가 사내에서 사내에 있는 시스템을 대상으로 했었기 때문에 큰 문제가 없었다. 그러나 근래 들어서 클라우드 컴퓨팅을 사용하는 사례가 늘어남에 따라, 서비스 시스템이 회사 밖에 즉, 클라우드에 있는 경우가 많아 졌다.</p>\n<p>상용 부하 테스트툴의 경우에는 부하 발생기의 위치와 툴 사용자에 대해서 제약을 두는 경우가 있는데, 툴을 구매했다 하더라도, 부하 테스터의 controller (부하 발생기 제외)는 반드시 사내에 있어야 하며, 사용자 역시 그 회사의 내부 직원으로만 한정하는 경우가 있다.</p>\n<p>예를 들어, 내가 부하 테스트 도구를 서울에 있는 회사에서 구매하여, 이 툴을 Amazon 클라우드 미국에 설치하고 부하 테스트를 미국 지사 직원을 통해서 진행하는 것이 불가능 하다.</p>\n<p>이 경우 부하 테스트 툴의 Controller는 한국 서울 사무소에 설치하고, 부하 생성기만 Amazon에 설치한후 한국 서울 사무소 직원을 통해서만 사용해야 한다.</p>\n<p>간혹 (이럴리는 없어야 하겠지만) 부하 테스트 툴의 판매 회사 영업 사원이 이러한 사실을 제대로 통보하지 않아서, 툴을 잘 쓰다가 갑자기 영업 사원이 변경되거나, 부하 테스트 툴의 이전을 요청 하였을때, 갑자기 벤더로 부터, 추가 라이센스 구매 요청을 받을 수 있으니, 구매 전에 반드시 구매 조건에 사용 시나리오와Controller 위치, 사용 주체 및 테스트 대상 시스테들에 대해서 명시적으로 기재 하고 구매 계약을 추진 하는 것이 좋다.</p>\n<p>|</p>\n<h3 id=\"테스트-및-모니터링\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%8F-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-label=\"테스트 및 모니터링 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 및 모니터링</h3>\n<p>부하 테스트 준비가 되었으면, 부하 테스트를 진행하고 진행중에 주요 성능 Factor에 대해서 지속적으로 모니터링 및 기록을 하여야 한다. 주로 모니터링해야하는 Factor들은 다음과 같다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/2467683E5226098A21\" alt=\"\"></p>\n<p>① 애플리케이션 관점</p>\n<p>가장 기본적으로 애플리케이션 즉 시스템의 성능을 측정 해야 한다. 주요 모니터링 Factor는 다음과 같다.</p>\n<p>Response Time : Request 별 응답 시간</p>\n<p>TPS (Throughput per second) : 초당 요청(Request) 처리량</p>\n<p>이 Factor들이 궁극적으로 성능에 대한 최종 목표 값이 되기 때문에, 가장 중요한 성능 Factor가 되며, 부하 생성 도구를 통해서 손쉽게 측정할 수 있다.</p>\n<p>② 미들웨어 관점</p>\n<p>미들웨어는 애플리케이션이 동작하기 위한 기본적인 솔루션이다.. Apache와 같은 웹서버나 Tomcat과 같은 Web Application 서버 , RabbitMQ와 같은 Message Queue, MySQL 과 같은 데이타 베이스 등이 이에 해당한다.</p>\n<p>각 성능 시나리오별로, 거쳐 가는 모든 미들웨어들을 모니터링해야 하는데, 이를 위해서는 각 솔루션에 대한 개별적인 깊은 이해가 필요하다.</p>\n<p>웹서버의 경우 거의 성능 문제가 되는 부분은 없다. 성능 문제가 발생하는 부분은 대부분 Network outbound io (bandwidth)쪽이 되는 경우가 많다 . 웹서버가 설치된 하드웨어의 network out bound bandwidth를 모니터링 하는 것이 유용하다.</p>\n<p>대부분의 성능 문제는 실제 애플리케이션 로직이 수행되는 Tomcat과 같은 application server와 데이타 베이스단에서 많이 발생하는데, application server의 경우에는 Thread의 수와 Queue의 길이가 1차 모니터링 대상이 된다.</p>\n<p>서버가 용량을 초과 하게 되면, Idle Thread수가 떨어지게 되고, Idle Thread가 0이 되면 request message가 앞단의 queue에 저장되게 된다. 그래서 이 두 개를 모니터링 하면 시스템이 병목 상태인지 아닌지를 판단할 수 있다. 이 값들은 JMX (Java Management Extension) API를 이용하여 모니터링 하면 된다.</p>\n<p>DB의 경우에는 slow query를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다. MySQL 5.6의 경우 slow query는 <a href=\"http://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html\">http://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html</a></p>\n<p>를 사용하면 쉽게 잡아낼 수 있다.</p>\n<p>Slow query를 찾았으면, EXPLAIN 명령어를 이용하여 query 의 수행 내용을 분석한후 Index등의 튜닝을 수행할 수 있다.</p>\n<p><a href=\"http://dev.mysql.com/doc/refman/5.0/en/using-explain.html\">http://dev.mysql.com/doc/refman/5.0/en/using-explain.html</a></p>\n<p>③ 인프라 관점 : CPU, Memory, Network IO, Disk IO</p>\n<p>다음으로 하드웨어 인프라에 대한 부분을 지속적으로 모니터링해줘야 하는데, 이는 하드웨어가 해당 성능을 내기 위해서 용량이 충분한지 그리고 하드웨어 구간에서 병목이 생기지는 않는지, 생긴다면 어느 구간에서 생기는지를 모니터링하여, 해당 병목 구간에 대한 문제 해결을 하기 위함이다.</p>\n<p>인프라에 대한 모니터링은 Ganglia나 Cacti와 같은 전문화된 인프라 모니터링 도구를 사용하거나 top이나 glance, sar와 같은 기본적인 Unix/Linux 커맨드를 사용해서도 모니터링이 가능하다. (부하 테스트주에 top 등을 띄워놓고 모니터링을 하는 것이 좋다. Load Runner와 같은 상용 도구의 경우에는 부하 테스트 툴 자체에서 테스트 대상 시스템에 대한 하드웨어 사용률을 함께 모니터링할 수 있게 제공해준다.)</p>\n<p><strong>CPU :</strong> 일반적으로 CPU는 대부분 잘 모니터링 한다 . 목표 성능을 달성할 시에는 보통 70<del>80% 정도의 CPU 를 사용하는 것이 좋고 , 20</del>30%의 여유는 항상 가지고 가는 것이 좋다 이유는, 70~80% 정도의 CPU가 사용된 후에, 하드웨어를 물리적으로 늘리는 시간에 대한 여유 시간을 가지기 위함이다. 하드웨어는 특성상 주문을한다고 해도 , 바로 그 시간에 증설을 할 수 있는 것이 아니고, CPU 가 100%가 되는 순간에는 이미 애플리케이션이 CPU 부족으로 제대로 작동을 하지 못하는 경우가 많기 때문에, 항상 여유를 남겨 놓고 성능 목표를 정의 하는 것이 좋다 . 그래서 성능 목표를 잡을 때는 “CPU 70%시, 500 TPS, 응답시간 1.5 초 내외” 식으로 하드웨어에 대한 사용률을 포함하는 것을 권장한다.</p>\n<p><strong>Memory :</strong> 다음으로는 Memory 부분이다 . Peak Time 시에 Memory가 얼마나 사용되느냐가 중요한데, Java Application의 경우 특성상, 전체 JVM 프로세스가 사용할 메모리량을 미리 정해놓기 때문에, 부하 테스트 중에도 메모리 사용량 자체는 크게 변화하지 않는다. 다만 자주 놓치는 점이 swapping status 인데, Unix/Linux는 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해서 virtual memory 라는 개념을 사용하고 swapping space라는 디스크 공간에 자주 사용하지 않는 메모리의 내용을 dump해서 저장한 후 다시 사용할때 memory에 loading 하는 방식을 사용한다. 그런데 이 메모리의 내용을 디스크에 저장 및 로드 하는 과정 (swapping이라고 함)이 실제 disk io를 발생 시키기 때문에, 실제 메모리 access 성능이 매우 급격하게 떨어진다. 그래서 시스템에서 system에서 swapping 이 발생하면 시스템의 성능이 장애 수준으로 매우 급격하게 떨어진다.</p>\n<p>부하 테스트 중이나, 운영 중에 swapping이 발생하게 되면 전체 메모리 사용량을 줄이도록 튜닝을 하거나, 반대로 물리 메모리를 늘리는 증설 과정이 필요하다.</p>\n<p><strong>Disk IO :</strong> Disk IO는 파일 시스템에 파일을 저장하는 시나리오나, Log를 저장하는 모듈 그리고 데이타 베이스와 같이 뒷단에 파일 시스템을 필요로 하는 모듈에서 많이 발생을 한다. Ganglia와 같은 도구를 사용하면, IOPS (Input Out per Second - 초당 read/write 등의 IO 발생 횟수)를 통해서 모니터링할 수 있고, 또는 iostat나 sar와 같은 명령어를 이용하면 iowait 를 통해서 디스크 IO의 pending이 발생할 경우 디스크 병목이 있는지 없는지를 확인할 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/25573944522609991F\" alt=\"\"></p>\n<p>Figure 1 . iostat</p>\n<p>또는 Process당 Disk IO는 iotop과 같은 툴을 사용하면 조금 더 상세한 정보를 얻을 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/23284044522609A533\" alt=\"\"></p>\n<p>Figure 2 . iotop</p>\n<p><a href=\"file:///C:/Users/terry/Desktop/%EB%AC%B8%EC%84%9C/Dropbox/%EC%A1%B0%EB%8C%80%ED%98%91%EC%9D%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C/%EC%9E%91%EC%97%85%EC%A4%91%EC%9D%B8%20%EC%B1%95%ED%84%B0/8%EC%9E%A5%20%EC%84%B1%EB%8A%A5%20%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-130824.docx#_ftn1\">[1]</a></p>\n<p>Disk IO에 대한 Bottleneck은 여러가지 해결 방법이 있다. 먼저 하드웨어 인프라 ㅈ체에서 접근 하는 방식은, 디스크 자체를 SSD로 변경하거나 , 버퍼가 크거나 RPM이 높은 디스크로 변경하는 방식, 인터페이스를 SATA에서 SAS나 SSD와 같은 높은 IO를 제공하는 디스크 인터페이스로 변경, Disk Controller는 iSCSI에서 FC/HBA와 같은 광케이블 기반의 고속 컨트롤러를 사용하는 방식 또는 RAID 구성을 Stripping 방식으로 변경해서 IO를 여러 디스크로 분산 시키는 방식 등이 있으며, 애플리케이션 차원에서는 데이타 베이스 앞에 memcache와 같은 캐슁을 사용하거나, 로깅의 경우에는 중간에 message queue를 써서 로그를 다른 서버에서 쓰도록 하여 IO를 분산하거나 또는 Back write와 같은 방식으로 로그 메세지가 발생할때 마다 disk에 writing 하는 것이 아니라 20개 30개씩 한꺼번에 디스크로 flushing 하는 방식등을 이용할 수 있다.</p>\n<p>또는 조금더 높은 아키텍쳐 레벨로는 디스크 IO가 많이 발생하는 로직의 경우 동기 처리에서 message queue를 사용하는 비동기 방식으로 시스템의 설계를 변경하는 방법을 고민할 수 있다 . 예를 들어 사진을 올려서 변환하는 서비스의 경우 파일을 업로드 하는 시나리오와 변경하는 모듈을 물리적으로 분리하여, 파일 업로드가 끝나면 , 사용자에게 동기 방식으로 바로 응답을 줘서 응답 시간을 빠르게 하고, 업로드된 파일은 뒷단에서 비동기 프로세스를 통해서 변환 과정을 다 끝낸 후에 사용자에게 변환이 끝나면 알려주는 방법을 사용할 수 있다.</p>\n<p>Network IO: Network IO는 특히 고용량의 파일이나 이미지 전송에서 병목이 많이 발생하며, Reverse Proxy, NAT (Network address Translator), Router, Load Balancer 등에서 많이 발생한다. 여러가지 지점과 장비에 대해서 모니터링 해야 하기 때문에, 일반적인 unix/linux command 를 사용하는 방법보다는 Cacti나 Ganglia와 같은 RRD 툴이나 OpenNMS와 같은 NMS (Network Management System)을 사용하는게 좋다.</p>\n<p>그래프를 보면서 추이를 지켜 보는 것이 중요한데, 부하를 넣으면 일정 수준이 되어도, 시스템들의 CPU 나 메모리, Disk등의 기타 자원들은 넉넉한데, Network Input/Output이 일정 수준 이상으로 올라가지 않는 경우가 있다. 이 경우는 네트워크 구간의 병목일 가능성이 높다.</p>\n<p>특히 소프트웨어 기반의 Load Balancer나, 소프트웨어 기반의 NAT 장비에서 많이 발생하는데, 이미지와 같은 정적 컨텐츠는 가급적이면 CDN이나 분리된 Web Server를 이용해서 서비스 하도록 하는 것이 좋다. 클라우드의 경우에는 특히나 소프트웨어 기반의 NAT나 Load Balancer 를 사용해서 문제가 되는 경우가 많은데, NAT의 경우에는 여러개의 NAT를 사용해서 로드를 분산하도록 하고 , Load Balancer의 경우에도 충분히 큰 용량을 사용하거나 2개 이상의 Load Balancer를 배포한 후 DNS Round Robine등을 사용하는 방법을 고려 하는 것이 좋다.</p>\n<h3 id=\"개선-tuning\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%84%A0-tuning\" aria-label=\"개선 tuning permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개선 (Tuning)</h3>\n<p>병목을 찾았으면, 해당 병목 문제를 해결 및 반영해야 한다.</p>\n<p>튜닝은 병목 구간이 발생하는 부분에 대한 전문적인 지식을 필요로 하지만, 기본적인 접근 방법은 거의 같다고 보면 된다.</p>\n<p>① 문제의 정의 : 성능 개선의 가장 기본은 문제 자체를 제대로 정의 하는 것이다. “그냥 느려요”가 아니라, “ 성능 목표가 350TPS에 1초내의 응답 시간인데, 현재 60 TPS에 5 초의 응답 시간에 WAS의 CPU 점유율이 100% 입니다.”와 같이 명확해야 하며, 문제점이 재현 가능해야 한다.</p>\n<p>특히 재현 가능성은 매우 중요한 점인데, 테스트 환경이 잘못되었거나, 외부적 요인 예를 들어 부하 테스트 당시 네트워크 회선이 다른 테스트로 인하여 대역폭이 충분히 나오지 않았거나 했을 경우 결과가 그 때마다 다르게 나올 수 있다.</p>\n<p>즉 문제 자체를 명확하게 정의할 필요가 있다.</p>\n<p>② Break down : 다음으로는 문제가 발생하는 부분이 어떤 부분인지를 판단해야 한다. 시스템은 앞단의 로드밸런서나 미들웨어, 데이타 베이스와 같은 여러 구간에서 발생을 한다 . 그렇기 때문에, 성능 저하의 원인이 정확하게 어느 부분인지를 인지하려면, 먼저 성능 시나리오가 어떤 어떤 컴포넌트를 거치는지를 명확하게 할 필요가 있다. 이 과정을 break down 이라고 한다. 이 과정을 통해서 전체 성능 구간중, 어느 구간이 문제를 발생 하는지를 정의한다.</p>\n<p>③ Isolate : 다음으로는 다른 요인들을 막기 위해서, 문제가 되는 구간을 다른 요인으로 부터 분리 (고립) 시킨다. 물론 완벽한 분리는 어렵다. 애플리케이션이 동작하기 위해서는 데이타 베이스가 필수적으로 필요하다 . 이 경우에는 데이타 베이스를 분리할 수 는 없다. 그러나 예를 들어 시나리오 자체가 로그인 시나리오이고 Single Sign On을 통해서 로그인 하는 시나리오라서 SSO 시스템과 연동이 되어 있다면, SSO 연동을 빼고 다른 mock up을 넣어서 SSO와의 연결성을 끊고 테스트를 하는 것이 좋다.</p>\n<p>이렇게 문제에 대한 다른 요인과의 연관성을 최대한 제거 하는 작업이 isolation이다.</p>\n<p>④ Narrow down : 문제를 isolation을 시켰으면 , 근본적인 문제를 찾기 위해서 문제의 원인을 파 내려간다. Profiling을 하거나, 코드에 디버그 정보를 걸어서 문제의 원인을 분석하는 과정을 narrow down이라고 한다. 특히나 이 narrow down 과정은 분석을 위한 여러가지 기법이나 도구들을 사용해야 하고, 현상에 대한 이해를 하기 위해서는 해당 솔루션이나 기술 분야에 대한 전문성은 필수적으로 필요하다.</p>\n<p>⑤ Bottleneck 발견 : Narrow down을 해서 문제의 원인을 계속 파해쳐 나가면 병목의 원인이 되는 근본적인 문제가 판별이 된다.</p>\n<p>⑥ 해결 : 일단 병목의 원인을 찾으면 해결을 해야 하는데, 찾았다고 모두 해결이 되는건 아니다. 데이타 베이스 index 를 걸지 않아서 index를 걸어주면 되는 간단한 문제도 있을 수 있지만, 근본적인 솔루션 특성이나 설계상의 오류로 인해서 문제가 발생하는 경우도 있다. 하드웨어를 늘려서 해결하는 방법도 있지만 , 비지니스 시나리오 자체를 바꾸거나 UX 관점에서 해결 하는 방법도 고려할 수 있다. 예를 들어 로그인 화면이 넘어가는데 시간이 많이 걸린다고 했을때, 이 문제가 근본적으로 솔루션의 특성이라면 애플리케이션이나 솔루션 수정으로는 해결이 불가능하다. 이런 경우에는 모래 시계 아이콘이나 progress bar등을 넣어서 UX 관점에서 사용자로 하여금 체감되는 응답 시간에 대해서 느리지 않고 몬가 진행이 되고 있다고 보여주는 형태로 접근을 해서 문제를 해결할 수 도 있다.</p>\n<p>간단한 예를 하나 들어보자. Drupal 이라는 웹 CMS 기반의 웹사이트가 있다고 하자. 성능 테스트를 수행하였는데, CPU 점유율이 지나치게 높게 나오고 응답 시간이 느리게 나왔다 . 이것이 문제의 정의이다.</p>\n<p>성능의 문제점을 찾아내기 위해서, 성능 테스트 시나리오를 검토하였다 성능 테스트 시나리오는 1) 로그인 페이지 로딩, 2) id,password를 post로 전송 3) 초기 화면으로 redirect됨 4) 로그 아웃 4 가지 과정을 거치고 있었다. 1,2,3,4 과정의 응답시간을 각각 체크해서 보니, 2) 과정에서 성능의 대부분을 차지 하고 있음을 찾아 내었다. 전체적으로 성능이 안나오는 것을 인지한 후 , 문제를 여러 구간으로 나누어서 접근 하는 것이 Break down이다.</p>\n<ol start=\"2\">\n<li>과정을 분석하기 위해서 성능 테스트를 다시 진행한다. 다른 시나리오가 영향을 주는 것을 방지하기 위해서 , 1,3,4 시나리오를 제외 하고, 2 시나리오만 가지고 성능 테스트를 진행한다. 이렇게 문제점을 다른 변수로 부터 분리하여 고립 시키는 것을 isolation이라고 한다.</li>\n</ol>\n<p>다음으로 Xhprof 라는 프로파일링 툴을 사용하여 로직중 어느 부분이 가장 성능 문제가 발생하는 지를 profiling 하였다. 대 부분의 성능 저하가 SQL 문장 수행에서 발생함을 찾아내었다. 이렇게 하나의 포인트를 깊게 들어 가면서 범위를 좁혀가는 것을 narrow down이라고 한다.</p>\n<p>SQL 수행이 문제가 있음을 정의하고(문제의 정의 ), 어떤 SQL 문장이 수행되는지(Break down) 각각을 정의한후, 가장 수행 시간이 긴 SQL 문장을 찾아서 원인을 분석하였더니(narrow down) index 가 걸려 있지 않음을 찾아내었다.</p>\n<p>해당 테이블에 index를 적용하고, 성능 테스트를 다시 수행하여 성능 목표치를 달성하였음을 해결하였다.</p>\n<p>가상의 시나리오지만 성능 튜닝의 접근 방법은 대부분 유사 하다. 관건은 문제를 어떻게 잘 정의하고, 문제가 어떤 요소로 구성이 되어 있으며 각각이 어떤 구조로 동작을 하고 있는지 잘 파고 들어갈 수 있는 문제에 대한 접근 능력과, 점점 솔루션의 아랫부분(low level)로 들어갈 수 있는 전문성이 필요하다.</p>\n<h3 id=\"반복\" style=\"position:relative;\"><a href=\"#%EB%B0%98%EB%B3%B5\" aria-label=\"반복 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>반복</h3>\n<p>튜닝이 끝났으면 다시 “테스트 및 모니터링” 항목으로 돌아가서 성능 목표에 도달할때까지 위의 작업을 계속해서 반복해서 수행한다.</p>\n<h2 id=\"performance-engineering을-위해-필요한-것들\" style=\"position:relative;\"><a href=\"#performance-engineering%EC%9D%84-%EC%9C%84%ED%95%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%83%EB%93%A4\" aria-label=\"performance engineering을 위해 필요한 것들 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Performance Engineering을 위해 필요한 것들</h2>\n<p>그러면 성능 엔지니어링을 하기 위해서 필요한 것들은 무엇이 있을까? 먼저 도구 적인 측면부터 살펴보자.</p>\n<p>① 부하 테스트기 : 가장 기초적으로 필요한 것은 부하 발생 도구 이다. HP Load Runner와 같은 상용 도구에서 부터, nGrinder와 같은 오픈 소스 기반의 대규모 부하 발생 도구를 사용할 수 도 있고 , SOAP UI같은 micro benchmark 테스트 툴을 이용해서 소규모 (50 사용자 정도)를 발생 시키거나 필요에 따라서는 간단하게 Python등의 스크립트 언어로 부하를 발생시킬 수 도 있다.</p>\n<p>② 모니터링 도구 : 다음으로는 모니터링 도구이다. 어느 구간이 문제가 있는지 현상이 어떤지를 파악하려면 여러 형태의 모니터링 도구들이 필요하다.</p>\n<p>③ 프로파일링 도구 : 그리고, 문제되는 부분을 발견했을때 , 그 문제에 대한 근본적인 원인을 찾기 위해서 프로파일링을 할 수 있는 도구들이 필요하다.</p>\n<p>우리가 일반적으로 이야기 하는 프로파일링 도구들은 IDE와 같은 개발툴에서 debug 용도로 사용은 가능하지만, 대부분 대규모 부하 환경에서는 사용이 불가능한 경우가 많다.그래서 그런 경우에는 해당 시스템의 상태에 대한 스냅샷을 추출 할 수 있는 dump 도구들을 많이 사용하는데 , unix process의 경우에는 ptrace를 통해서 system call 을 모니터링 하거나, pmap을 이용하여 메모리 snapshot등을 추출할 수 도 있고 , 자바의 경우에는 thread dump를 추출해서 병목 당시 애플리케이션이 무슨 동작을 하고 있었는지를 찾아낼 수 있다.</p>\n<p>다음이 이 글에서 정말 언급하고 싶은 내용인데, 앞에서 도구를 언급했다면 다음은 엔지니어로써의 역량이나 지식적인 부분이다.</p>\n<p>④ 역량 : 당연한 것이겠지만, 기술적인 역량은 필수적이다 . netstat를 통해서 TCP 소켓이 FIN_WAIT 가 발생하였는데, 이 FIN_WAIT가 의미하는 것이 무엇인지 모르면 아무리 모니터링을 잘해도 소용이 없다. 기본적인 엔지니어로써의 컴퓨터와 프로그래밍, OS등에 대한 넓은 이해는 필수적이다.</p>\n<p>⑤ 하드웨어 인프라, 미들웨어 , 애플리케이션에 대한 지식 : 다음은 사용하는 특정 솔루션에 대한 전문적인 지식이다. 톰캣의 내부 구조가 어떻게 되어 있으며, JVM의 동작원리가 어떻게 되는지와 같은 특정 지식인데, 사실 이러한 지식은 오랜 경험이나 습득할 시간이 없으면 가지기가 어렵다. 이런 경우는 해당 솔루션 제품 엔지니어를 통해서 지원을 받는 방법도 고려해볼만 하다.</p>\n<p>⑥ 그리고 경험 : 성능 엔지니어링에 대한 경험인데, 대략 시스템의 상태마 봐도 어느 부분이 의심이 되는지 경험이 많은 엔지니어는 쉽게 접근을 한다. 성능 문제는 넓어보이기는 하지만, 결국 발생되는 패턴이 거의 일정하다. 그리고 특정 솔루션에 대한 지식이 없다하더라도, 문제에 대한 접근 하는 방법이나 모니터링 방법, 툴등은 사용법이 다르다 하더라도 그 의미하는 방법은 거의 비슷하기 때문에, 다른 기술로 구현되어 있는 시스템이라고 하더라도 , 경험이 있는 엔지니어는 문제를 접근해서 풀어나가는 방식이 매우 익숙하다.</p>\n<p>⑦ 마지막으로 인내심 : 그리고 마지막으로 강조하고 싶은 점이 인내심인데, 사실 성능 엔지니어링은 상당히 지루한 작업이다. 반복적인 테스트와 모니터링 및 분석을 거쳐야 하고, 해당 솔루션에 대한 전문적인 지식이 없을 경우에는 보통 제품 문제라고 치부하고 하드웨어 업그레이드로 가는 경우가 많은데, 어짜피 솔루션이라고 해도 소스코드로 만들어진 프로그램이다. 디컴파일을 하건, 덤프를 추출하건, 꾸준히 보고, 오픈 소스의 경우 소스코드를 참고해서 로직을 따라가다 보변, 풀어낼 수 있는 문제가 대부분이다. 결국은 시간과 인내심의 싸움인데, 꾸준하게 인내심을 가지고 문제를 접근하고 풀어나가는 것을 반복하면 문제는 풀린다.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<p><a href=\"https://bcho.tistory.com/787\">조대협 블로그</a></p>"},{"frontmatter":{"tags":["typescript eslint 설정"],"title":"typescript eslint 설정"},"internal":{"content":"\n# typescript eslint 설정\n\nvscode eslint 확장프로그램 설치\n\n```bash\nyarn add --dev eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin\n```\n\n```js\n// .eslintrc.js\nmodule.exports = {\n  root: true,\n  parser: \"@typescript-eslint/parser\",\n  plugins: [\"@typescript-eslint\"],\n  extends: [\"eslint:recommended\", \"plugin:@typescript-eslint/recommended\"],\n}\n```\n\n## eslint 실행\n\n```bash\nyarn run eslint [폴더위치] --ext .js,.jsx,.ts,.tsx\nyarn run eslint . --ext .js,.jsx,.ts,.tsx\n```\n\n## airbnb lint 적용하기\n\n```bash\nyarn add -D eslint-config-airbnb-typescript \\\n            @typescript-eslint/eslint-plugin@^5.0.0 \\\n            @typescript-eslint/parser@^5.0.0\n```\n\n```js\nmodule.exports = {\n  root: true,\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    tsconfigRootDir: __dirname,\n    project: [\"./tsconfig.json\"],\n  },\n  plugins: [\"@typescript-eslint\"],\n  extends: [\"airbnb-typescript\"],\n}\n```\n\n## 참고문서\n\n[공식 typescript eslint](https://typescript-eslint.io/docs/linting/)\n\n[eslint-config-airbnb-typescript npm](https://www.npmjs.com/package/eslint-config-airbnb-typescript)\n"},"html":"<h1 id=\"typescript-eslint-설정\" style=\"position:relative;\"><a href=\"#typescript-eslint-%EC%84%A4%EC%A0%95\" aria-label=\"typescript eslint 설정 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>typescript eslint 설정</h1>\n<p>vscode eslint 확장프로그램 설치</p>\n<pre><code class=\"language-bash\">yarn add --dev eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin\n</code></pre>\n<pre><code class=\"language-js\">// .eslintrc.js\nmodule.exports = {\n  root: true,\n  parser: \"@typescript-eslint/parser\",\n  plugins: [\"@typescript-eslint\"],\n  extends: [\"eslint:recommended\", \"plugin:@typescript-eslint/recommended\"],\n}\n</code></pre>\n<h2 id=\"eslint-실행\" style=\"position:relative;\"><a href=\"#eslint-%EC%8B%A4%ED%96%89\" aria-label=\"eslint 실행 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>eslint 실행</h2>\n<pre><code class=\"language-bash\">yarn run eslint [폴더위치] --ext .js,.jsx,.ts,.tsx\nyarn run eslint . --ext .js,.jsx,.ts,.tsx\n</code></pre>\n<h2 id=\"airbnb-lint-적용하기\" style=\"position:relative;\"><a href=\"#airbnb-lint-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"airbnb lint 적용하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>airbnb lint 적용하기</h2>\n<pre><code class=\"language-bash\">yarn add -D eslint-config-airbnb-typescript \\\n            @typescript-eslint/eslint-plugin@^5.0.0 \\\n            @typescript-eslint/parser@^5.0.0\n</code></pre>\n<pre><code class=\"language-js\">module.exports = {\n  root: true,\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    tsconfigRootDir: __dirname,\n    project: [\"./tsconfig.json\"],\n  },\n  plugins: [\"@typescript-eslint\"],\n  extends: [\"airbnb-typescript\"],\n}\n</code></pre>\n<h2 id=\"참고문서\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%AC%B8%EC%84%9C\" aria-label=\"참고문서 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고문서</h2>\n<p><a href=\"https://typescript-eslint.io/docs/linting/\">공식 typescript eslint</a></p>\n<p><a href=\"https://www.npmjs.com/package/eslint-config-airbnb-typescript\">eslint-config-airbnb-typescript npm</a></p>"},{"frontmatter":{"tags":["github"],"title":"github publickey deny"},"internal":{"content":"\n**git permission denied (publickey). fatal:Could not readfromremote repository. Please make sure you have the correct access rights and therepositoryexists**\n\n**문제**\n\ngit clone, git pull 등 PC에서 명령어를 쳤는데 위와 같은 에러가 난 적이 있을 것이다. git clone하면서 에러가 났는데 이유는 즉슨, 필자의 경우는 기존과 다른 PC에서 접속했는데 SSH key가 이 PC에 없는 경우 이 에러가 났다.\n\n**이유**\n\ngit은 SSH 또는 http 기반으로 사용을 하게 되는데 SSH key로 접속해서 사용하는 경우는 PC마다 SSH key를 등록해 주어야 한다.\n\n**해결방법**\n\n1\\. 터미널창을 열고 ssh key 생성 명령어 입력한다.\n\n```\n$ ssh-keygen -t rsa -C \"[본인의 Github 계정 이메일주소]\"\n```\n\n![](https://blog.kakaocdn.net/dn/DTQLV/btq9e6RA4hl/RvZrjGONT2YAeyYof2ddJ0/img.png)\n\n2\\. Enter 입력. id_rsa 파일의 생성되고 경로는 **C:\\\\Users\\\\\\[사용자\\]/.ssh/id_rsa** 이다.\n\n![](https://blog.kakaocdn.net/dn/bo1Zlm/btq9aeKBHNy/VoEWZnl5mpYYbBZF6DXYjK/img.png)\n\n3\\. 비밀번호 입력을 원하면 비밀번호 입력, 아니면 Enter\n\n![](https://blog.kakaocdn.net/dn/eu6Btd/btq9aMz0s22/DOn2esB8GtiOX6dwD4ccYk/img.png)\n\n4\\. SSH key가 생성 되었다.\n\n![](https://blog.kakaocdn.net/dn/YKRXV/btq9eFfMBN9/KpdU9xYCRmZ8i2ZSWnZiS1/img.png)\n\n5\\. Github에 Settings 메뉴로 이동한다.\n\n![](https://blog.kakaocdn.net/dn/qbf7S/btq9fdJRPAs/ITrKKA959pNTDvCpJIJR4K/img.png)\n\n6\\. Settings에서 SSH keys를 누르면 아래와 같은 화면이 나온다. New SSH key 버튼 클릭하면 SSH key 값을 입력하는 란이 나온다.\n\n![](https://blog.kakaocdn.net/dn/cUGV0h/btq9dwp3WPt/1ZQpDPZPXfhTIzEjif08r0/img.png)\n\n7\\. .ssh 폴더에 id_rsa.pub 파일을 메모장이나 NotePad로 열어보면 key값이 보일 것이다. 전체 복사해서 아까 SSH key 값 입력하는 곳에 붙여준다.\n\n![](https://blog.kakaocdn.net/dn/dqR6es/btq9aFnLhDK/GypBoXFGLFHsHgmJxaE701/img.png)\n\n8\\. 생성이 완료되었으면 PC에 잘 generate 되었는지 터미널에서 확인해보자.\n\n```\n$ ssh -T git@github.com\n```\n\n![](https://blog.kakaocdn.net/dn/elpWAv/btq9aeRshTE/uloUZIhk48wNQep3qZgOpK/img.png)\n\n처음엔 첫번째와 같은 에러가 떴는데 잠시 후 다시 시도하니 잘 인증되었다. 이러고나서 git clone 하니 성공적으로 clone까지 완료되었다.\n"},"html":"<p><strong>git permission denied (publickey). fatal:Could not readfromremote repository. Please make sure you have the correct access rights and therepositoryexists</strong></p>\n<p><strong>문제</strong></p>\n<p>git clone, git pull 등 PC에서 명령어를 쳤는데 위와 같은 에러가 난 적이 있을 것이다. git clone하면서 에러가 났는데 이유는 즉슨, 필자의 경우는 기존과 다른 PC에서 접속했는데 SSH key가 이 PC에 없는 경우 이 에러가 났다.</p>\n<p><strong>이유</strong></p>\n<p>git은 SSH 또는 http 기반으로 사용을 하게 되는데 SSH key로 접속해서 사용하는 경우는 PC마다 SSH key를 등록해 주어야 한다.</p>\n<p><strong>해결방법</strong></p>\n<p>1. 터미널창을 열고 ssh key 생성 명령어 입력한다.</p>\n<pre><code>$ ssh-keygen -t rsa -C \"[본인의 Github 계정 이메일주소]\"\n</code></pre>\n<p><img src=\"https://blog.kakaocdn.net/dn/DTQLV/btq9e6RA4hl/RvZrjGONT2YAeyYof2ddJ0/img.png\" alt=\"\"></p>\n<p>2. Enter 입력. id_rsa 파일의 생성되고 경로는 <strong>C:\\Users\\[사용자]/.ssh/id_rsa</strong> 이다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bo1Zlm/btq9aeKBHNy/VoEWZnl5mpYYbBZF6DXYjK/img.png\" alt=\"\"></p>\n<p>3. 비밀번호 입력을 원하면 비밀번호 입력, 아니면 Enter</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/eu6Btd/btq9aMz0s22/DOn2esB8GtiOX6dwD4ccYk/img.png\" alt=\"\"></p>\n<p>4. SSH key가 생성 되었다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/YKRXV/btq9eFfMBN9/KpdU9xYCRmZ8i2ZSWnZiS1/img.png\" alt=\"\"></p>\n<p>5. Github에 Settings 메뉴로 이동한다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/qbf7S/btq9fdJRPAs/ITrKKA959pNTDvCpJIJR4K/img.png\" alt=\"\"></p>\n<p>6. Settings에서 SSH keys를 누르면 아래와 같은 화면이 나온다. New SSH key 버튼 클릭하면 SSH key 값을 입력하는 란이 나온다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cUGV0h/btq9dwp3WPt/1ZQpDPZPXfhTIzEjif08r0/img.png\" alt=\"\"></p>\n<p>7. .ssh 폴더에 id_rsa.pub 파일을 메모장이나 NotePad로 열어보면 key값이 보일 것이다. 전체 복사해서 아까 SSH key 값 입력하는 곳에 붙여준다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/dqR6es/btq9aFnLhDK/GypBoXFGLFHsHgmJxaE701/img.png\" alt=\"\"></p>\n<p>8. 생성이 완료되었으면 PC에 잘 generate 되었는지 터미널에서 확인해보자.</p>\n<pre><code>$ ssh -T git@github.com\n</code></pre>\n<p><img src=\"https://blog.kakaocdn.net/dn/elpWAv/btq9aeRshTE/uloUZIhk48wNQep3qZgOpK/img.png\" alt=\"\"></p>\n<p>처음엔 첫번째와 같은 에러가 떴는데 잠시 후 다시 시도하니 잘 인증되었다. 이러고나서 git clone 하니 성공적으로 clone까지 완료되었다.</p>"},{"frontmatter":{"tags":["crypto nodepolifill"],"title":"crypto nodepolifill"},"internal":{"content":"\n# crypto nodepolifill\n\nwebpack을 업데이트 함으로서\ncrypto 패키지를 불러오지 못한 에러가 생겼다\n\n이유인 즉슨\n\n## Node.js 자동 Polyfill 제거\n\nwebpack4버전 이하에서는 브라우저 호환성을 위해 Node.js 모듈에 대한 polyfill을 자동으로 제공했지만 대부분의 polyfill이 불필요하게 적용되어 bundle size를 증가시키기 때문에 이를 제거하였습니다.\n\nPackage maintainer에게 package.json에 browser필드를 추가하여 브라우저 호환성을 명시할 것을 당부하고 있습니다.\n\n> 실제 사례: crypto를 사용하는(혹은 사용하는 dependency중에서 사용하는 패키지가 있는 경우) 이 변경사항에 대응하지 않으면 프로젝트 빌드가 정상적으로 수행되지 않습니다.\n\n제외된 package목록은 [webpack5 - Do not polyfill node bindings by default PR](https://github.com/webpack/webpack/pull/8460/commits/a68426e9255edcce7822480b78416837617ab065) 에서 확인하실 수 있습니다.\n\nRef: [https://medium.com/@sanchit3b/how-to-polyfill-node-core-modules-in-webpack-5-905c1f5504a0](https://medium.com/@sanchit3b/how-to-polyfill-node-core-modules-in-webpack-5-905c1f5504a0)\n\n그렇기에\n\n```bash\nyarn add -D node-polyfill-webpack-plugin\n```\n\n추가를 해주고\n\nwebpack에 다음 코드를 추가 해주면 해결된다\n\n```bash\nconst NodePolyfillPlugin = require(\"node-polyfill-webpack-plugin\")\nmix.webpackConfig(webpack => {\n    return {\n        plugins: [\n            new NodePolyfillPlugin()\n        ]\n    };\n});\n\n```\n"},"html":"<h1 id=\"crypto-nodepolifill\" style=\"position:relative;\"><a href=\"#crypto-nodepolifill\" aria-label=\"crypto nodepolifill permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>crypto nodepolifill</h1>\n<p>webpack을 업데이트 함으로서\ncrypto 패키지를 불러오지 못한 에러가 생겼다</p>\n<p>이유인 즉슨</p>\n<h2 id=\"nodejs-자동-polyfill-제거\" style=\"position:relative;\"><a href=\"#nodejs-%EC%9E%90%EB%8F%99-polyfill-%EC%A0%9C%EA%B1%B0\" aria-label=\"nodejs 자동 polyfill 제거 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js 자동 Polyfill 제거</h2>\n<p>webpack4버전 이하에서는 브라우저 호환성을 위해 Node.js 모듈에 대한 polyfill을 자동으로 제공했지만 대부분의 polyfill이 불필요하게 적용되어 bundle size를 증가시키기 때문에 이를 제거하였습니다.</p>\n<p>Package maintainer에게 package.json에 browser필드를 추가하여 브라우저 호환성을 명시할 것을 당부하고 있습니다.</p>\n<blockquote>\n<p>실제 사례: crypto를 사용하는(혹은 사용하는 dependency중에서 사용하는 패키지가 있는 경우) 이 변경사항에 대응하지 않으면 프로젝트 빌드가 정상적으로 수행되지 않습니다.</p>\n</blockquote>\n<p>제외된 package목록은 <a href=\"https://github.com/webpack/webpack/pull/8460/commits/a68426e9255edcce7822480b78416837617ab065\">webpack5 - Do not polyfill node bindings by default PR</a> 에서 확인하실 수 있습니다.</p>\n<p>Ref: <a href=\"https://medium.com/@sanchit3b/how-to-polyfill-node-core-modules-in-webpack-5-905c1f5504a0\">https://medium.com/@sanchit3b/how-to-polyfill-node-core-modules-in-webpack-5-905c1f5504a0</a></p>\n<p>그렇기에</p>\n<pre><code class=\"language-bash\">yarn add -D node-polyfill-webpack-plugin\n</code></pre>\n<p>추가를 해주고</p>\n<p>webpack에 다음 코드를 추가 해주면 해결된다</p>\n<pre><code class=\"language-bash\">const NodePolyfillPlugin = require(\"node-polyfill-webpack-plugin\")\nmix.webpackConfig(webpack => {\n    return {\n        plugins: [\n            new NodePolyfillPlugin()\n        ]\n    };\n});\n\n</code></pre>"},{"frontmatter":{"tags":["Cypress url 쿠키 삭제하는 문제"],"title":"Cypress url 쿠키 삭제하는 문제"},"internal":{"content":""},"html":""}],"distinct":["Cypress url 쿠키 삭제하는 문제","crypto nodepolifill","github","typescript eslint 설정","고성능 아키텍쳐","블로그 포스팅","웹개발 개념정리","코딩표준","쿠버네티스/도커"]}}}